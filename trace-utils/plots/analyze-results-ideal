#!/usr/bin/env python
#=========================================================================
# analyze-results-ideal
#=========================================================================
#
#  -h --help           Display this message
#
#  --no-spmd           Turn off spmd data-points
#  --no-wsrt           Turn off wsrt data-points
#  --no-perf           Turn off performance normalization
#  --plot              Turn off table and show the plot
#
# Author : Shreesha Srinath
# Date   : January 22nd, 2018
#
# Quick and dirty script to parse results for wsrt similarity on the
# abstract MIMD architecture
#

import argparse
import os
import sys
import re
import subprocess

import pandas as pd

import brg_plot

from common import *

#-------------------------------------------------------------------------
# Utility Function
#-------------------------------------------------------------------------

def execute(cmd):
  try:
    #print cmd
    return subprocess.check_output(cmd, shell=True)
  except  subprocess.CalledProcessError, err:
    return err

#-------------------------------------------------------------------------
# Global variable
#-------------------------------------------------------------------------

g_resultsdir_path = "../results-%s-similarity-limit-%d"

#-------------------------------------------------------------------------
# Command line processing
#-------------------------------------------------------------------------

class ArgumentParserWithCustomError(argparse.ArgumentParser):
  def error( self, msg = "" ):
    if ( msg ): print("\n ERROR: %s" % msg)
    print("")
    file = open( sys.argv[0] )
    for ( lineno, line ) in enumerate( file ):
      if ( line[0] != '#' ): sys.exit(msg != "")
      if ( (lineno == 2) or (lineno >= 4) ): print( line[1:].rstrip("\n") )

def parse_cmdline():
  p = ArgumentParserWithCustomError( add_help=False )

  # Standard command line arguments

  p.add_argument( "-h", "--help", action="store_true" )

  # Additional commane line arguments for the simulator

  p.add_argument( "--no-spmd",   action="store_false", default=True   )
  p.add_argument( "--no-wsrt",   action="store_false", default=True   )
  p.add_argument( "--no-perf",   action="store_false", default=True   )
  p.add_argument( "--plot",      action="store_true",  default=False  )

  opts = p.parse_args()
  if opts.help: p.error()
  return opts

#-------------------------------------------------------------------------
# summarize
#-------------------------------------------------------------------------

def summarize(runtime):

  data = []
  for limit in [1,250]:
    resultsdir_path = g_resultsdir_path % ( runtime, limit )
    subfolders = os.listdir( resultsdir_path )
    for subfolder in subfolders:
      try:
        app = re.sub("-parc", '', subfolder)
        app = re.sub("-small", '', app)
        app = re.sub("-mtpull", '', app)
        app = re.sub("-mt", '', app)

        if not app in app_short_name_dict.keys():
          continue

        res_file =  resultsdir_path + '/' + subfolder + '/' + subfolder + '.out'
        cmd = 'grep -r -A 35 "Serial steps in stats region =" %(res_file)s' % { 'res_file' : res_file }
        lines = execute( cmd )
        total = 0
        iredundancy = 0
        for line in lines.split('\n'):
          if line != '':
            if 'Total steps' in line:
              total = int(line.split()[-1])
            elif 'Redundancy in parallel regions' in line:
              iredundancy = line.split()[-1]

        config = "%s-mimd-limit-%d" % ( runtime, limit )
        data.append([app_short_name_dict[app],config,total,iredundancy])
      except:
        print "{} limit-{} {}: Results file not present".format( runtime, limit, subfolder )
        continue

  columns = ['app','config','steps','iredundancy']
  df = pd.DataFrame(data,columns=columns)
  return df

#-------------------------------------------------------------------------
# print table
#-------------------------------------------------------------------------

def print_table( df, base_df, print_perf=True ):
  for app in app_short_name_dict.values():
    if app in base_df.app.unique():
      ts = base_df.loc[base_df.app == app,['steps']].iloc[0]
      df.loc[df.app == app, ['steps']] = \
        float(ts)/df.loc[df.app == app, ['steps']]

  configs = df.config.unique()
  print "{:^21s}".format("kernel") + ("{:^21s}"*len(configs)).format(*configs)
  for app in app_short_name_dict.values():
    if app in base_df.app.unique():
      out = "{:^18s}".format(app)
      for config in configs:
        red  = df.loc[(df.app == app) & (df.config == config), ['iredundancy']].iloc[0]
        if print_perf:
          perf = df.loc[(df.app == app) & (df.config == config), ['steps']].iloc[0]
          out += "{:^10.2f} {:^10.2f}".format( float(perf), float(red) )
        else:
          out += "{:^20.2f}".format( float(red) )
      print out

#-------------------------------------------------------------------------
# plot 
#-------------------------------------------------------------------------

def plot( base_df, df, spmd, wsrt ):
  
  # normalize all data
  for app in app_short_name_dict.values():
    if spmd:
      try:
        ts = base_df.loc[base_df.app == app,['steps']].iloc[0]
        df.loc[df.app == app, ['steps']] = \
          float(ts)/df.loc[df.app == app, ['steps']]
      except:
        if wsrt:
          ts = df.loc[(df.app == app) & (df.config == 'wsrt-mimd-limit-1'),['steps']].iloc[0]
          df.loc[df.app == app, ['steps']] = \
            float(ts)/df.loc[df.app == app, ['steps']]
          continue
    else:
      ts = base_df.loc[base_df.app == app,['steps']].iloc[0]
      df.loc[df.app == app, ['steps']] = \
        float(ts)/df.loc[df.app == app, ['steps']]

  # create plot options dict
  opts = brg_plot.PlotOptions()
  attribute_dict = \
  {
    'show'            : False,
    'plot_type'       : 'bar',
    'figsize'         : (16.0, 8.0),
    'rotate_labels'   : False,
    'markersize'      : 50,
    'labels_fontsize' : 1,
    'legend_enabled'  : False,
    'bar_width'       : 0.5,
  }
  for name, value in attribute_dict.iteritems():
    setattr( opts, name, value )

  # figure out the labels
  spmd_legend_labels = [
    'spmd',
    'spmd-hint',
  ]

  wsrt_legend_labels = [
    'wsrt',
    'wsrt-hint',
  ] 

  if not spmd:
    legend_labels = wsrt_legend_labels
  elif not wsrt:
    legend_labels = spmd_legend_labels
  else:
    legend_labels = spmd_legend_labels + wsrt_legend_labels

  # collect data
  redun_data = []
  steps_data = []
 
  for app in app_short_name_dict.values():
    temp_steps = []
    temp_redun = []
    for config in df.config.unique():
      try:
        temp_steps.append( df.loc[(df.app == app) & (df.config == config), ['steps']].iloc[0]['steps'] )
        temp_redun.append( df.loc[(df.app == app) & (df.config == config), ['iredundancy']].iloc[0]['iredundancy'] )
      except:
        temp_steps.append(float('nan'))
        temp_redun.append(float('nan'))
    steps_data.append( temp_steps )
    redun_data.append( temp_redun )

  # set plot options
  opts.num_cols = 1
  opts.num_rows = 2

  # plot redundancy
  opts.plot_idx       = 1
  opts.data           = redun_data 
  opts.legend_ncol    = len(legend_labels)
  opts.rotate_labels  = True
  opts.labels         = [app_list,legend_labels]
  opts.colors         = brg_plot.colors['qualitative_paired']
  opts.normalize_line = 75.0
  #opts.title          = "Instruction Redundancy"
  opts.ylabel         = "Precent Redundant Insns."
  opts.legend_enabled = True

  brg_plot.add_plot( opts )

  # plot performance
  opts.plot_idx       = 2
  opts.data           = steps_data 
  opts.legend_ncol    = len(legend_labels)
  opts.rotate_labels  = True
  opts.labels         = [app_list,legend_labels]
  opts.colors         = brg_plot.colors['qualitative_paired']
  #opts.title          = "Normalized Performance"
  opts.normalize_line = 1
  opts.ylabel         = "Perf. Normalized to %s" % ( 'wsrt' if not spmd else 'spmd' )  
  opts.legend_enabled = True
  opts.file_name      = 'ideal-machine.pdf'

  brg_plot.add_plot( opts )


#-------------------------------------------------------------------------
# main
#-------------------------------------------------------------------------

if __name__ == "__main__":
  opts = parse_cmdline()

  spmd_df = summarize("spmd")
  wsrt_df = summarize("wsrt")

  if not opts.no_wsrt:
    df = spmd_df
    base_df = df[df.config == "spmd-mimd-limit-1"].copy()
    if opts.plot:
      plot( base_df, df, spmd=True, wsrt=False )
    else:
      print_table( df, base_df, opts.no_perf )
  elif not opts.no_spmd:
    df = wsrt_df
    base_df = df[df.config == "wsrt-mimd-limit-1"].copy()
    if opts.plot:
      plot( base_df, df, spmd=False, wsrt=True )
    else:
      print_table( df, base_df, opts.no_perf )
  else:
    df = pd.concat([spmd_df,wsrt_df])
    base_df = df[df.config == "spmd-mimd-limit-1"].copy()
    if opts.plot:
      plot( base_df, df, spmd=True, wsrt=True )
    else:
      print_table( df, base_df, opts.no_perf )
