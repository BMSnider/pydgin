#!/usr/bin/env python
#=========================================================================
# tpa-redundancy-plot [options]
#=========================================================================
#
#  -h --help          Display this message
#
#  --runtime          Select runtime
#                       [spmd,wsrt]
#  --component        Select what to plot
#
# Author : Shreesha Srinath
# Date   : March 9th, 2018
#

import argparse
import re
import math
import sys

import pandas as pd
pd.set_option('display.width', 100)

import brg_plot

from common import *
from process_data import *

#-------------------------------------------------------------------------
# Command line processing
#-------------------------------------------------------------------------

class ArgumentParserWithCustomError(argparse.ArgumentParser):
  def error( self, msg = "" ):
    if ( msg ): print("\n ERROR: %s" % msg)
    print("")
    file = open( sys.argv[0] )
    for ( lineno, line ) in enumerate( file ):
      if ( line[0] != '#' ): sys.exit(msg != "")
      if ( (lineno == 2) or (lineno >= 4) ): print( line[1:].rstrip("\n") )

def parse_cmdline():
  p = ArgumentParserWithCustomError( add_help=False )

  # Standard command line arguments

  p.add_argument( "-h", "--help",    action="store_true" )

  # Additional commane line arguments for the simulator

  p.add_argument( "--component", action="store", default="redundancy",
                  choices=["iaccess","redundancy"] )
  p.add_argument( "--runtime", action="store", default="spmd",
                  choices=["spmd", "wsrt"] )

  opts = p.parse_args()
  if opts.help: p.error()
  return opts

#-------------------------------------------------------------------------
# main
#-------------------------------------------------------------------------
# NOTE: Since, we use a L0 buffer in mimd I think it's better to use
# frontend as a proxy for results without the L0 buffer

if __name__ == "__main__":
  p_opts  = parse_cmdline()
  runtime = p_opts.runtime

  # read the dataframe
  df = pd.read_csv( g_sim_results_file )

  # compute normalized delay and iaccess
  base_cfg = 'mimd-%s-1-0AH' % runtime
  df['normalized_delay']   = df['steps']
  df['normalized_iaccess'] = df['unique_frontend']
  for app in app_list:
    try:
      base_steps = float(df.loc[(df.app == app) & (df.config == base_cfg), 'steps'].iloc[0])
      df.loc[(df.app==app) & df.config.str.contains(runtime), 'normalized_delay'] = \
        df.loc[(df.app==app) & df.config.str.contains(runtime), 'normalized_delay'] / base_steps
      base_iaccess = float(df.loc[(df.app == app) & (df.config == base_cfg), 'total_frontend'].iloc[0])
      df.loc[(df.app==app) & df.config.str.contains(runtime), 'normalized_iaccess'] = \
        df.loc[(df.app==app) & df.config.str.contains(runtime), 'normalized_iaccess'] * 100 / base_iaccess
    except:
      continue

  # compute redundancy
  df['redundancy'] = df['total_frontend'] - df['unique_frontend'] 
  df.loc[:,'redundancy'] *= 100.0
  df['redundancy'] = df['redundancy']/df['total_frontend'] 

  # set the option for what to plot
  if p_opts.component == "iaccess":
    ylabel  = "Normalized Insn. Access (%)"
    ycolumn = "normalized_iaccess"
    normalize_line = 100 
  elif p_opts.component == "redundancy":
    ylabel  = "Instruction Redundancy (%)"
    ycolumn = "redundancy"
    normalize_line = 75 

  # create plot options dict
  opts = brg_plot.PlotOptions()
  attribute_dict = \
  {
    'show'            : False,
    'plot_type'       : 'bar',
    'figsize'         : (8.0, 4.0),
    'rotate_labels'   : True,
    'rotate_angle'    : 30,
    'markersize'      : 60,
    'labels_fontsize' : 1,
    'legend_enabled'  : False,
  }
  for name, value in attribute_dict.iteritems():
    setattr( opts, name, value )

  # plot array 
  opts.num_cols = 1
  opts.num_rows = 1

  config_list = [
    'mimd-%s-1-0AH' % runtime,
    'mimd-%s-1000-0AH' % runtime,
  ]

  # determine the apps
  kernels_list = []
  if   runtime == "spmd":
    kernels_list += app_custom_list
    kernels_list += app_pbbs_list
  elif runtime == "wsrt":
    kernels_list += app_custom_list
    kernels_list += app_pbbs_list
    kernels_list += app_cilk_list

  index = 0
  delay_data = []
  yaxis_data = [] 
  labels = []
  for app in kernels_list:
    temp_delay = []
    temp_yaxis = []
    for cfg in config_list:
      try: 
        delay = df.loc[(df.config == cfg) & (df.app == app), 'normalized_delay'].iloc[0]
        yaxis = df.loc[(df.config == cfg) & (df.app == app), ycolumn].iloc[0]
        temp_delay.append( delay ) 
        temp_yaxis.append( yaxis ) 
        if app not in labels:
          labels.append( app )
      except:
        continue
    if temp_delay: delay_data.append( temp_delay )
    if temp_yaxis: yaxis_data.append( temp_yaxis )

  # add plot
  opts.data           = yaxis_data  
  opts.labels         = [labels,['baseline','hint']]
  opts.legend_ncol    = 2
  opts.legend_enabled = True
  opts.plot_idx       = index+1
  opts.ylabel         = ylabel
  opts.normalize_line = normalize_line
  opts.colors         = ['#616161', '#8aae92']
  opts.legend_bbox    = (0,0.98,1.,0.1)
  brg_plot.add_plot( opts )

  opts.fig.text( 0.52, 1.0, "%s" % runtime.upper(), ha='center', fontsize=10)
  brg_plot.plt.tight_layout()
  file_name  = '%s-redundancy.pdf' % runtime
  brg_plot.plt.savefig( file_name, bbox_inches="tight" )
