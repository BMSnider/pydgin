#!/usr/bin/env python
#=========================================================================
# tpa-mimd-dynamic-plot [options]
#=========================================================================
#
#  -h --help          Display this message
#
#  --runtime          Select runtime
#                       [spmd,wsrt]
#
# Author : Shreesha Srinath
# Date   : March 10th, 2018
#

import argparse
import re
import math
import sys

import pandas as pd
pd.set_option('display.width', 100)

import brg_plot

from common import *
from process_data import *

#-------------------------------------------------------------------------
# Command line processing
#-------------------------------------------------------------------------

class ArgumentParserWithCustomError(argparse.ArgumentParser):
  def error( self, msg = "" ):
    if ( msg ): print("\n ERROR: %s" % msg)
    print("")
    file = open( sys.argv[0] )
    for ( lineno, line ) in enumerate( file ):
      if ( line[0] != '#' ): sys.exit(msg != "")
      if ( (lineno == 2) or (lineno >= 4) ): print( line[1:].rstrip("\n") )

def parse_cmdline():
  p = ArgumentParserWithCustomError( add_help=False )

  # Standard command line arguments

  p.add_argument( "-h", "--help",    action="store_true" )

  # Additional commane line arguments for the simulator

  p.add_argument( "--runtime", action="store", default="spmd",
                  choices=["spmd", "wsrt"] )

  opts = p.parse_args()
  if opts.help: p.error()
  return opts

#-------------------------------------------------------------------------
# main
#-------------------------------------------------------------------------
# NOTE: Since, we use a L0 buffer in mimd I think it's better to use
# frontend as a proxy for results without the L0 buffer

if __name__ == "__main__":
  p_opts  = parse_cmdline()
  runtime = p_opts.runtime

  # read the dataframe
  df = pd.read_csv( g_sim_results_file )

  # compute normalized delay and iaccess
  base_cfg = 'mimd-%s-1-0AH' % runtime
  df['delay']           = df['steps']
  df['iaccess']         = df['unique_frontend']
  df['iaccess_l0']      = df['unique_iaccess']
  df['iaccess_l0_only'] = df['total_iaccess'] - df['total_l0_hits']
  for app in app_list:
    try:
      base_steps = float(df.loc[(df.app == app) & (df.config == base_cfg), 'steps'].iloc[0])
      df.loc[(df.app==app) & df.config.str.contains(runtime), 'delay'] = \
        df.loc[(df.app==app) & df.config.str.contains(runtime), 'delay'] / base_steps
      base_iaccess = float(df.loc[(df.app == app) & (df.config == base_cfg), 'total_frontend'].iloc[0])
      df.loc[(df.app==app) & df.config.str.contains(runtime), 'iaccess'] = \
        df.loc[(df.app==app) & df.config.str.contains(runtime), 'iaccess'] * 100 / base_iaccess
      df.loc[(df.app==app) & df.config.str.contains(runtime), 'iaccess_l0'] = \
        df.loc[(df.app==app) & df.config.str.contains(runtime), 'iaccess_l0'] * 100 / base_iaccess
      df.loc[(df.app==app) & df.config.str.contains(runtime), 'iaccess_l0_only'] = \
        df.loc[(df.app==app) & df.config.str.contains(runtime), 'iaccess_l0_only'] * 100 / base_iaccess
    except:
      continue

  # create plot options dict
  opts = brg_plot.PlotOptions()
  attribute_dict = \
  {
    'show'            : False,
    'plot_type'       : 'bar',
    'figsize'         : (16.0, 8.0),
    'rotate_labels'   : True,
    'rotate_angle'    : 30,
    'markersize'      : 60,
    'labels_fontsize' : 1,
    'legend_enabled'  : False,
  }
  for name, value in attribute_dict.iteritems():
    setattr( opts, name, value )

  # plot array 
  opts.num_cols = 1
  opts.num_rows = 2

  # config list
  config_list = [
    'mimd-%s-1-0AH' % runtime,     
    'mimd-%s-1000-0AH' % runtime,  
  ]

  # determine the apps
  kernels_list = []
  if   runtime == "spmd":
    kernels_list += app_custom_list
    kernels_list += app_pbbs_list
  elif runtime == "wsrt":
    kernels_list += app_custom_list
    kernels_list += app_pbbs_list
    kernels_list += app_cilk_list

  delay_data = []
  yaxis_data = [] 
  labels = []

  # first collect iaccess without L0
  for app in kernels_list:
    temp_delay = []
    temp_yaxis = []
    # dyn        : iaccess 
    # dyn + hint : iaccess
    for cfg in config_list:
      try: 
        delay = df.loc[(df.config == cfg) & (df.app == app), 'delay'].iloc[0]
        yaxis = df.loc[(df.config == cfg) & (df.app == app), 'iaccess'].iloc[0]
        temp_delay.append( delay ) 
        temp_yaxis.append( yaxis ) 
        if app not in labels:
          labels.append( app )
      except:
        continue
    # L0 : iaccess_l0_only
    try:
      cfg = config_list[0]
      delay = df.loc[(df.config == cfg) & (df.app == app), 'delay'].iloc[0]
      yaxis = df.loc[(df.config == cfg) & (df.app == app), 'iaccess_l0_only'].iloc[0]
      temp_delay.append( delay )
      temp_yaxis.append( yaxis )
    except:
      pass

    # L0 + dyn        : iaccess_l0  
    # L0 + dyn + hint : iaccess_l0  
    for cfg in config_list:
      try: 
        delay = df.loc[(df.config == cfg) & (df.app == app), 'delay'].iloc[0]
        yaxis = df.loc[(df.config == cfg) & (df.app == app), 'iaccess_l0'].iloc[0]
        temp_delay.append( delay ) 
        temp_yaxis.append( yaxis ) 
      except:
        continue

    if temp_delay: 
      # append baseline
      temp_delay = [1] + temp_delay
      delay_data.append( temp_delay )
    if temp_yaxis: 
      # append baseline
      temp_yaxis = [100] + temp_yaxis
      yaxis_data.append( temp_yaxis )

  # legend labels
  legend_labels = [
    'base',
    'dyn',
    'dyn+hint',
    'l0',
    'l0+dyn',
    'l0+dyn+hint',
  ]  

  # add delay 
  opts.data           = delay_data  
  opts.labels         = [labels,legend_labels]
  opts.legend_ncol    = 6
  opts.legend_enabled = True
  opts.plot_idx       = 1
  opts.ylabel         = "Normalized Delay"
  opts.normalize_line = 1
  opts.colors         = brg_plot.colors['pubugn6']
  opts.legend_bbox    = (0,0.98,1.,0.1)
  brg_plot.add_plot( opts )

  # add iaccess
  opts.data           = yaxis_data  
  opts.labels         = [labels,legend_labels]
  opts.legend_ncol    = 6
  opts.legend_enabled = True
  opts.plot_idx       = 2
  opts.ylabel         = "Normalized Instruction Access (%)"
  opts.normalize_line = 100
  opts.colors         = brg_plot.colors['pubugn6']
  opts.legend_bbox    = (0,0.98,1.,0.1)
  brg_plot.add_plot( opts )


  opts.fig.text( 0.5, 1.0, "%s" % runtime.upper(), ha='center', fontsize=10)
  brg_plot.plt.tight_layout()
  file_name = '%s-mimd-dynamic.pdf' % runtime
  brg_plot.plt.savefig( file_name, bbox_inches="tight" )
