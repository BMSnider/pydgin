#!/usr/bin/env python
#=========================================================================
# tpa-l0-imem-llfu-only-plot [options]
#=========================================================================
#
#  -h --help          Display this message
#
#  --runtime          Select runtime
#                       [spmd,wsrt]
#
# Author : Shreesha Srinath
# Date   : March 10th, 2018
#

import argparse
import re
import math
import sys

import pandas as pd
pd.set_option('display.width', 100)

import brg_plot

from common import *
from common_configs import *

#-------------------------------------------------------------------------
# Command line processing
#-------------------------------------------------------------------------

class ArgumentParserWithCustomError(argparse.ArgumentParser):
  def error( self, msg = "" ):
    if ( msg ): print("\n ERROR: %s" % msg)
    print("")
    file = open( sys.argv[0] )
    for ( lineno, line ) in enumerate( file ):
      if ( line[0] != '#' ): sys.exit(msg != "")
      if ( (lineno == 2) or (lineno >= 4) ): print( line[1:].rstrip("\n") )

def parse_cmdline():
  p = ArgumentParserWithCustomError( add_help=False )

  # Standard command line arguments

  p.add_argument( "-h", "--help",    action="store_true" )

  # Additional commane line arguments for the simulator

  p.add_argument( "--runtime", action="store", default="spmd",
                  choices=["spmd", "wsrt"])

  opts = p.parse_args()
  if opts.help: p.error()
  return opts

#-------------------------------------------------------------------------
# global variables
#-------------------------------------------------------------------------

g_cfg_prefix = "conj-cores-%s"
g_cfg_str    = "-%dL0-%dI-%dF-%dL-%dC-%dTS-%dLO-%d-%dLL-%dAH"

#-------------------------------------------------------------------------
# populate_configs()
#-------------------------------------------------------------------------

def populate_configs( runtime ):
  ncores         = 4
  limit_lockstep = 0
  adaptive_hint  = 0
  configs_list   = []
  cfg_prefix     = g_cfg_prefix % runtime
  for l0_buffer_sz in [0,1]:
    for coalescing in [0,1]:
      for barrier_limit in [1,1000]:
        if coalescing == 0 and barrier_limit == 1000:
          continue
        for insn_ports in [1,2]:
          for resources in [1,2]:
            if (insn_ports != resources) and (resources < ncores):
              continue
            for lockstep in [1,2]:
              for analysis in [0,1]:
                configs_list.append(
                  cfg_prefix +
                  g_cfg_str % (
                    l0_buffer_sz,
                    insn_ports,
                    ncores,
                    resources,
                    coalescing,
                    analysis,
                    lockstep,
                    barrier_limit,
                    limit_lockstep,
                    adaptive_hint
                  )
                )
  return configs_list

#-------------------------------------------------------------------------
# is_pareto_front()
#-------------------------------------------------------------------------

def is_pareto_front(row, stats, xlabel, ylabel):
  x = row[xlabel]
  y = row[ylabel]

  # look for points with the same y value but smaller x value
  is_min_x = stats.loc[stats[ylabel]==y].max()[xlabel] >= x
  # look for points with the same x value but smaller y value
  is_min_y = stats.loc[stats[xlabel]==x].max()[ylabel] >= y

  # look for points that are smaller in both x and y
  is_min_xy = len(stats.loc[(stats[xlabel]<x) & (stats[ylabel]<y)])==0

  return is_min_x and is_min_y and is_min_xy

#-------------------------------------------------------------------------
# get_pareto_data()
#-------------------------------------------------------------------------

def get_pareto_data( frame_data ):  
  columns=['config','app','delay','yaxis']
  stats = pd.DataFrame(frame_data,columns=columns)  
  is_pareto = stats.apply(lambda row: is_pareto_front(row, stats, 'delay', 'yaxis'), axis=1)
  pareto_data = stats.loc[is_pareto].sort_values(by='delay')
  return [pareto_data['delay'].values, pareto_data['yaxis'].values]

#-------------------------------------------------------------------------
# normalize_results
#-------------------------------------------------------------------------

def normalize_results( df, base_df, runtime ):
  base_cfg = g_mimd_base_str % runtime
  for app in app_list:
    try:
      base_steps = float(base_df.loc[(base_df.app == app) & (base_df.config == base_cfg), 'steps'].iloc[0])
      df.loc[(df.app==app) & df.config.str.contains(runtime), 'normalized_delay'] = \
        df.loc[(df.app==app) & df.config.str.contains(runtime), 'normalized_delay'] / base_steps
      #print base_steps
      #print df.loc[(df.app==app) & df.config.str.contains(runtime),['config','normalized_delay']]

      base_yaxis = float(base_df.loc[(base_df.app == app) & (base_df.config == base_cfg), 'total_iaccess'].iloc[0])
      df.loc[(df.app==app) & df.config.str.contains(runtime), 'normalized_yaxis'] = \
        df.loc[(df.app==app) & df.config.str.contains(runtime), 'normalized_yaxis'] * 100/ base_yaxis
    except:
      continue
  return df    

#-------------------------------------------------------------------------
# plot()
#-------------------------------------------------------------------------

def plot( df, base_df, runtime, configs_list ):

  # filter the configs
  l0_list, no_l0_list = filter_configs( "-1L0-", configs_list )

  # determine the apps
  kernels_list = []
  if   runtime == "spmd":
    kernels_list += app_custom_list
    kernels_list += app_pbbs_list
  elif runtime == "wsrt":
    kernels_list += app_custom_list
    kernels_list += app_pbbs_list
    kernels_list += app_cilk_list

  # populate data
  data  = []
  stats = []
  for cfg_list in [no_l0_list, l0_list]:
    temp = []
    for cfg in cfg_list:
      for app in kernels_list:
        try:
          delay = df.loc[(df.config == cfg) & (df.app == app), 'normalized_delay'].iloc[0]
          yaxis = df.loc[(df.config == cfg) & (df.app == app), 'normalized_yaxis'].iloc[0]
          temp.append( [delay, yaxis] )
          stats.append( [cfg, app, delay, yaxis] )
        except:
          continue
    if temp: data.append( temp )

  # collect pareto points
  pareto_data = get_pareto_data( stats )

  # create plot options dict
  opts = brg_plot.PlotOptions()
  attribute_dict = \
  {
    'show'            : False,
    'plot_type'       : 'scatter',
    'figsize'         : (8.0, 8.0),
    'rotate_labels'   : False,
    'markersize'      : 60,
    'labels_fontsize' : 1,
    'legend_enabled'  : False,
  }
  for name, value in attribute_dict.iteritems():
    setattr( opts, name, value )

  # plot array 
  opts.num_cols       = 1
  opts.num_rows       = 1 
  #opts.yrange         = [0,105]
  opts.data           = data
  opts.index          = 1
  opts.pareto_points  = False
  opts.pareto_data    = pareto_data
  opts.labels         = [[],['no L0','L0']]
  opts.legend_enabled = True
  opts.legend_ncol    = 2
  opts.colors         = ['#616161', '#8aae92'] 
  opts.symbols        = ['o', 'o']
  opts.title          = runtime
  opts.ylabel         = 'Normalized Insn. Access (%)' 
  opts.xlabel         = 'Normalized Delay'
  opts.file_name      = '%s-l0-imem-llfu-only.pdf' % runtime
  
  brg_plot.add_plot( opts )

#-------------------------------------------------------------------------
# main
#-------------------------------------------------------------------------

if __name__ == "__main__":
  # parse options
  opts = parse_cmdline()
  
  # get the runtime
  runtime = opts.runtime

  # read the results
  all_results = pd.read_csv( "sim-l0-results.csv" )

  # skip non-zero values which indicate missing data
  all_results = all_results[all_results!=0]

  # add new columns
  all_results['normalized_delay'] = all_results['steps']
  all_results['normalized_yaxis'] = all_results['unique_iaccess']

  # baseline mimd results are present in a different file
  base_df = pd.read_csv( g_sim_results_file )

  # populate all configs
  configs_list = populate_configs( runtime )

  # get the dataframe of interest
  df = all_results[all_results.config.isin( configs_list )].copy()

  # get normalized results
  df = normalize_results( df, base_df, runtime )

  # plot
  plot( df, base_df, runtime, configs_list )  
