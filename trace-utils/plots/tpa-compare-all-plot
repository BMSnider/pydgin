#!/usr/bin/env python
#=========================================================================
# tpa-compare-all-plot [options]
#=========================================================================
#
#  -h --help          Display this message
#
#  --runtime          Select runtime
#                       [spmd,wsrt]
#  --resources        Select number of resources[1,2]
#
# Author : Shreesha Srinath
# Date   : March 17th, 2018
#

import argparse
import re
import math
import sys

import numpy as np

import pandas as pd
pd.set_option('display.width', 1000)

from scipy.stats.mstats import gmean

import brg_plot

from collections import OrderedDict

from common import *
from common_configs import *

#-------------------------------------------------------------------------
# Command line processing
#-------------------------------------------------------------------------

class ArgumentParserWithCustomError(argparse.ArgumentParser):
  def error( self, msg = "" ):
    if ( msg ): print("\n ERROR: %s" % msg)
    print("")
    file = open( sys.argv[0] )
    for ( lineno, line ) in enumerate( file ):
      if ( line[0] != '#' ): sys.exit(msg != "")
      if ( (lineno == 2) or (lineno >= 4) ): print( line[1:].rstrip("\n") )

def parse_cmdline():
  p = ArgumentParserWithCustomError( add_help=False )

  # Standard command line arguments

  p.add_argument( "-h", "--help",    action="store_true" )

  # Additional commane line arguments for the simulator

  p.add_argument( "--runtime", action="store", default="spmd",
                  choices=["spmd", "wsrt"])
  p.add_argument( "--resources", type=int, action="store", default=1,
                  choices=[1,2])

  opts = p.parse_args()
  if opts.help: p.error()
  return opts

#-------------------------------------------------------------------------
# global variables
#-------------------------------------------------------------------------

g_ccores_cfg_prefix = "conj-cores-%s"
g_simt_cfg_prefix   = "simt-%s"
g_cfg_str           = "-%dL0-%dI-%dF-%dL-%dC-%dTS-%dLO-%d-%dLL-%dAH"

g_short_cfg_names = [
  "imem (b)",
  "imem (s)",
  "imem+fe (b)",
  "imem+fe (s)",
  "imem+llfu (b)",
  "imem+llfu (s)",
  "imem+fe+llfu (b)",
  "imem+fe+llfu (s)",
  "mt (b)",
  "mt (s)",
  "mimd",
]

#-------------------------------------------------------------------------
# populate_configs
#-------------------------------------------------------------------------

def populate_configs( runtime, num_resources ):
  max_resources  = 4
  limit_lockstep = 0
  adaptive_hint  = 0
  l0_buffer_sz   = 1
  coalescing     = 1
  barrier_limit  = 1000

  configs_list = []

  #-----------------------------------------------------------------------
  # imem configs: l0 + coalesce + rr + hint (na: lockstep)
  #-----------------------------------------------------------------------

  # baseline
  analysis      = 0
  lockstep      = 0
  barrier_limit = 1
  coalescing    = 0
  for insn_ports in range(num_resources,num_resources+1,1):
    cfg  = g_ccores_cfg_prefix % ( runtime )
    cfg += g_cfg_str % ( 
            l0_buffer_sz,
            insn_ports,
            max_resources,
            max_resources,
            coalescing,
            analysis,
            lockstep,
            barrier_limit,
            limit_lockstep,
            adaptive_hint
           )
    configs_list.append( cfg )

  # alternative
  analysis      = 0
  lockstep      = 0
  barrier_limit = 1000
  coalescing    = 1
  for insn_ports in range(num_resources,num_resources+1,1):
    cfg  = g_ccores_cfg_prefix % ( runtime )
    cfg += g_cfg_str % ( 
            l0_buffer_sz,
            insn_ports,
            max_resources,
            max_resources,
            coalescing,
            analysis,
            lockstep,
            barrier_limit,
            limit_lockstep,
            adaptive_hint
           )
    configs_list.append( cfg )
  #-----------------------------------------------------------------------

  #-----------------------------------------------------------------------
  # imem+fe configs: l0 + min-pc + hint (na: coalescing, lockstep) 
  #-----------------------------------------------------------------------

  # baseline
  coalescing    = 1
  lockstep      = 1
  barrier_limit = 1
  analysis      = 0
  for frontend in range(num_resources,num_resources+1,1):
    cfg  = g_simt_cfg_prefix % ( runtime )
    cfg += g_cfg_str % ( 
            l0_buffer_sz,
            frontend,
            frontend,
            max_resources,
            coalescing,
            analysis,
            lockstep,
            barrier_limit,
            limit_lockstep,
            adaptive_hint
           )
    configs_list.append( cfg )

  # alternative
  coalescing    = 1
  lockstep      = 1
  barrier_limit = 1
  analysis      = 1
  for frontend in range(num_resources,num_resources+1,1):
    cfg  = g_simt_cfg_prefix % ( runtime )
    cfg += g_cfg_str % ( 
            l0_buffer_sz,
            frontend,
            frontend,
            max_resources,
            coalescing,
            analysis,
            lockstep,
            barrier_limit,
            limit_lockstep,
            adaptive_hint
           )
    configs_list.append( cfg )
  #-----------------------------------------------------------------------

  #-----------------------------------------------------------------------
  # imem+llfu configs: l0 + coalesce + rr + hint
  #-----------------------------------------------------------------------
  
  # baseline
  analysis      = 0
  coalescing    = 0
  barrier_limit = 1
  lockstep      = 0
  for resources in range(num_resources,num_resources+1,1):
    cfg  = g_ccores_cfg_prefix % ( runtime )
    cfg += g_cfg_str % ( 
            l0_buffer_sz,
            resources,
            max_resources,
            resources,
            coalescing,
            analysis,
            lockstep,
            barrier_limit,
            limit_lockstep,
            adaptive_hint
           )
    configs_list.append( cfg )

  # alternative
  analysis      = 0
  coalescing    = 1
  barrier_limit = 1
  lockstep      = 1
  for resources in range(num_resources,num_resources+1,1):
    cfg  = g_ccores_cfg_prefix % ( runtime )
    cfg += g_cfg_str % ( 
            l0_buffer_sz,
            resources,
            max_resources,
            resources,
            coalescing,
            analysis,
            lockstep,
            barrier_limit,
            limit_lockstep,
            adaptive_hint
           )
    configs_list.append( cfg )
  #-----------------------------------------------------------------------

  #-----------------------------------------------------------------------
  # imem+fe+llfu configs: l0 + min-pc + hint (na: coalescing, lockstep) 
  #-----------------------------------------------------------------------
  
  # baseline
  coalescing    = 1
  lockstep      = 1
  barrier_limit = 1
  analysis      = 0
  for resources in range(num_resources,num_resources+1,1):
    cfg  = g_simt_cfg_prefix % ( runtime )
    cfg += g_cfg_str % ( 
            l0_buffer_sz,
            resources,
            resources,
            resources,
            coalescing,
            analysis,
            lockstep,
            barrier_limit,
            limit_lockstep,
            adaptive_hint
           )
    configs_list.append( cfg )

  # alternative
  coalescing    = 1
  lockstep      = 1
  barrier_limit = 1
  analysis      = 1
  for resources in range(num_resources,num_resources+1,1):
    cfg  = g_simt_cfg_prefix % ( runtime )
    cfg += g_cfg_str % ( 
            l0_buffer_sz,
            resources,
            resources,
            resources,
            coalescing,
            analysis,
            lockstep,
            barrier_limit,
            limit_lockstep,
            adaptive_hint
           )
    configs_list.append( cfg )
  #-----------------------------------------------------------------------

  #-----------------------------------------------------------------------
  # mt baseline + alternative
  configs_list.append( "mt-%s-%dTS-%d-%dAH" % ( runtime, 0, 1, adaptive_hint ) )
  configs_list.append( "mt-%s-%dTS-%d-%dAH" % ( runtime, 1, 1, adaptive_hint ) )
  #-----------------------------------------------------------------------

  configs_dict = OrderedDict( zip( g_short_cfg_names, configs_list ) )
  return configs_dict

#-------------------------------------------------------------------------
# isclose
#-------------------------------------------------------------------------
# copylifted:
# https://stackoverflow.com/questions/5595425/what-is-the-best-way-to-compare-floats-for-almost-equality-in-python

def isclose(a, b, rel_tol=1e-09, abs_tol=0.0):
    return abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol)

#-------------------------------------------------------------------------
# pareto_frontier
#-------------------------------------------------------------------------
# NOTE: abandoning the old method which had issues with comparing values
# with rounding. The new method below works any may not be elegant but does
# the trick for now!

def pareto_frontier( delay, yaxis, stats ):
  # sort the values based on delay numbers
  vals = sorted( [[delay[i], yaxis[i]] for i in range( len( delay ) )] )

  # add the first value from the sorted list to the frontier
  p_front = [ vals[0] ]
  # loop through the sorted list
  for pair in vals[1:]:
    # look for lower values of y and add it to the frontier
    if pair[1] < p_front[-1][1] or isclose( pair[1], p_front[-1][1], abs_tol=0.5 ): 
      p_front.append( pair )

  # mark pareto configs in place
  stats['is_pareto'] = False
  for pair in p_front:
    for index, row in stats.iterrows():
      if row['normalized_delay'] == pair[0] and row['normalized_yaxis'] == pair[1]:
        stats.set_value(index,'is_pareto',True)
  return stats

#-------------------------------------------------------------------------
# normalize_results
#-------------------------------------------------------------------------

def normalize_results( df, base_df, runtime, total_yaxis ):
  base_cfg = g_mimd_base_str % runtime
  for app in app_list:
    try:
      base_steps = float(base_df.loc[(base_df.app == app) & (base_df.config == base_cfg), 'steps'].iloc[0])
      df.loc[(df.app==app) & df.config.str.contains(runtime), 'normalized_delay'] = \
        df.loc[(df.app==app) & df.config.str.contains(runtime), 'normalized_delay'] / base_steps

      base_yaxis = float(base_df.loc[(base_df.app == app) & (base_df.config == base_cfg), total_yaxis].iloc[0])
      df.loc[(df.app==app) & df.config.str.contains(runtime), 'normalized_yaxis'] = \
        df.loc[(df.app==app) & df.config.str.contains(runtime), 'normalized_yaxis'] * 100/ base_yaxis
    except:
      continue
  return df    

#-------------------------------------------------------------------------
# main
#-------------------------------------------------------------------------

if __name__ == "__main__":
  # parse options
  opts = parse_cmdline()
  
  # get the runtime
  runtime   = opts.runtime
  resources = opts.resources

  # read the results
  all_results = pd.read_csv( g_sim_results_file )

  # skip non-zero values which indicate missing data
  all_results = all_results[all_results!=0]

  # add new columns
  all_results['normalized_delay'] = all_results['steps']
  all_results['normalized_yaxis'] = all_results['unique_iaccess']

  # baseline mimd results are present in a different file
  base_df = pd.read_csv( g_sim_results_file )

  # populate all the configs
  configs_dict = populate_configs( runtime, resources )

  # get the dataframe of interest
  df = all_results[all_results.config.isin( configs_dict.values() )].copy()

  # get normalized results
  df = normalize_results( df, base_df, runtime, 'total_iaccess' )

  # determine the apps
  kernels_list = []
  if   runtime == "spmd":
    kernels_list += app_custom_list
    kernels_list += app_pbbs_list
  elif runtime == "wsrt":
    kernels_list += app_custom_list
    kernels_list += app_pbbs_list
    kernels_list += app_cilk_list

  # create plot options dict
  opts = brg_plot.PlotOptions()
  attribute_dict = \
  {
    'show'            : False,
    'plot_type'       : 'scatter',
    'figsize'         : (4.0, 4.0),
    'rotate_labels'   : False,
    'markersize'      : 60,
    'labels_fontsize' : 1,
    'legend_enabled'  : False,
  }
  for name, value in attribute_dict.iteritems():
    setattr( opts, name, value )

  # plot array 
  opts.num_cols = 1
  opts.num_rows = 1
  
  data  = []
  for cfg in configs_dict.values():
    temp = []
    delay = gmean(df.loc[df.config == cfg, 'normalized_delay'])
    yaxis = gmean(df.loc[df.config == cfg, 'normalized_yaxis'])
    temp.append( [delay, yaxis] )
    data.append( temp )

  # add the last data point for mimd
  data = data + [[[1,100]]]

  opts.data           = data  
  opts.labels         = [[],g_short_cfg_names]
  opts.legend_ncol    = len(g_short_cfg_names)/4 + 1
  opts.legend_enabled = True
  opts.plot_idx       = 1
  opts.legend_bbox    = (0,1.1,1.,0.1)
  opts.title          = runtime
  opts.ylabel         = 'Normalized Instruction Access % (geo. mean)'
  opts.xlabel         = 'Normalized Delay (geo. mean)'
  opts.colors = [
    '#6baed6', # imem (b)
    '#08519c', # imem (s)
    '#74c476', # imem+fe (b)
    '#006d2c', # imem+fe (s)
    '#fd8d3c', # imem+llfu (b) 
    '#a63603', # imem+llfu (s)
    '#9e9ac8', # imem+fe+llfu (b)
    '#54278f', # imem+fe+llfu (s) 
    '#969696', # mt (b)
    '#252525', # mt (s)
    '#252525', # mimd
  ]
  opts.symbols = [
    'v', # imem (b)
    'v', # imem (s)
    '^', # imem+fe (b)
    '^', # imem+fe (s)
    '>', # imem+llfu (b) 
    '>', # imem+llfu (s)
    '<', # imem+fe+llfu (b)
    '<', # imem+fe+llfu (s) 
    'p', # mt (b)
    'p', # mt (s)
    'o', # mimd
  ]
  opts.file_name = 'geo-mean-%s-%d.pdf' % ( runtime, resources )

  # plot data
  brg_plot.add_plot( opts )
