#!/usr/bin/env python
#=========================================================================
# pareto-table [options]
#=========================================================================
#
#  -h --help          Display this message
#
#  --runtime          Select runtime
#                       [spmd,wsrt]
#
# Author : Shreesha Srinath
# Date   : March 12th, 2018
#
# For all the static configurations pick the optimal set of knobs and try
# to spit out a table or plot

import argparse
import re
import math
import sys

import numpy as np

import pandas as pd
pd.set_option('display.width', 1000)

import brg_plot

from collections import OrderedDict

from common import *
from common_configs import *

#-------------------------------------------------------------------------
# Command line processing
#-------------------------------------------------------------------------

class ArgumentParserWithCustomError(argparse.ArgumentParser):
  def error( self, msg = "" ):
    if ( msg ): print("\n ERROR: %s" % msg)
    print("")
    file = open( sys.argv[0] )
    for ( lineno, line ) in enumerate( file ):
      if ( line[0] != '#' ): sys.exit(msg != "")
      if ( (lineno == 2) or (lineno >= 4) ): print( line[1:].rstrip("\n") )

def parse_cmdline():
  p = ArgumentParserWithCustomError( add_help=False )

  # Standard command line arguments

  p.add_argument( "-h", "--help",    action="store_true" )

  # Additional commane line arguments for the simulator

  p.add_argument( "--runtime", action="store", default="spmd",
                  choices=["spmd", "wsrt"])

  opts = p.parse_args()
  if opts.help: p.error()
  return opts

#-------------------------------------------------------------------------
# global variables
#-------------------------------------------------------------------------

g_ccores_cfg_prefix = "conj-cores-%s"
g_simt_cfg_prefix   = "simt-%s"
g_cfg_str           = "-%dL0-%dI-%dF-%dL-%dC-%dTS-%dLO-%d-%dLL-%dAH"

g_short_cfg_names = [
  "1 imem",
  "2 imem",
  "1 imem+fe",
  "2 imem+fe",
  "1 imem+llfu",
  "2 imem+llfu",
  "1 imem+fe+llfu",
  "2 imem+fe+llfu",
  #"share all",
]

#-------------------------------------------------------------------------
# populate_optimal_configs
#-------------------------------------------------------------------------

def populate_optimal_configs( runtime ):
  max_resources  = 4
  limit_lockstep = 0
  adaptive_hint  = 0
  l0_buffer_sz   = 1
  coalescing     = 1
  barrier_limit  = 1000

  configs_list = []

  # imem configs: l0 + coalesce + rr + hint (na: lockstep)
  analysis = 0
  lockstep = 0
  for insn_ports in [1,2]:
    cfg  = g_ccores_cfg_prefix % ( runtime )
    cfg += g_cfg_str % ( 
            l0_buffer_sz,
            insn_ports,
            max_resources,
            max_resources,
            coalescing,
            analysis,
            lockstep,
            barrier_limit,
            limit_lockstep,
            adaptive_hint
           )
    configs_list.append( cfg )

  # imem+fe configs: l0 + min-pc + hint (na: coalescing, lockstep) 
  analysis = 1 
  lockstep = 1
  for frontend in [1,2]:
    cfg  = g_simt_cfg_prefix % ( runtime )
    cfg += g_cfg_str % ( 
            l0_buffer_sz,
            frontend,
            frontend,
            max_resources,
            coalescing,
            analysis,
            lockstep,
            barrier_limit,
            limit_lockstep,
            adaptive_hint
           )
    configs_list.append( cfg )

  # imem+llfu configs: l0 + coalesce + rr + hint
  analysis = 0
  lockstep = 1
  for resources in [1,2]:
    cfg  = g_ccores_cfg_prefix % ( runtime )
    cfg += g_cfg_str % ( 
            l0_buffer_sz,
            resources,
            max_resources,
            resources,
            coalescing,
            analysis,
            lockstep,
            barrier_limit,
            limit_lockstep,
            adaptive_hint
           )
    configs_list.append( cfg )

  # imem+fe+llfu configs: l0 + min-pc + hint (na: coalescing, lockstep) 
  analysis = 1 
  lockstep = 1
  for resources in [1,2]:
    cfg  = g_simt_cfg_prefix % ( runtime )
    cfg += g_cfg_str % ( 
            l0_buffer_sz,
            resources,
            resources,
            resources,
            coalescing,
            analysis,
            lockstep,
            barrier_limit,
            limit_lockstep,
            adaptive_hint
           )
    configs_list.append( cfg )

  # share everything
  #mt_cfg_prefix = "mt-%s"
  #mt_cfg_str    = "-%dTS-%d-%dAH"
  #for analysis in [0,1]:  
  #  cfg  = mt_cfg_prefix % ( runtime )
  #  cfg += mt_cfg_str % (
  #          analysis,
  #          barrier_limit,
  #          adaptive_hint  
  #         )
  #  configs_list.append( cfg )

  configs_dict = OrderedDict( zip( g_short_cfg_names, configs_list ) )
  return configs_dict

#-------------------------------------------------------------------------
# isclose
#-------------------------------------------------------------------------
# copylifted:
# https://stackoverflow.com/questions/5595425/what-is-the-best-way-to-compare-floats-for-almost-equality-in-python

def isclose(a, b, rel_tol=1e-09, abs_tol=0.0):
    return abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol)

#-------------------------------------------------------------------------
# pareto_frontier
#-------------------------------------------------------------------------
# NOTE: abandoning the old method which had issues with comparing values
# with rounding. The new method below works any may not be elegant but does
# the trick for now!

def pareto_frontier( delay, yaxis, stats ):
  # sort the values based on delay numbers
  vals = sorted( [[delay[i], yaxis[i]] for i in range( len( delay ) )] )

  # add the first value from the sorted list to the frontier
  p_front = [ vals[0] ]
  # loop through the sorted list
  for pair in vals[1:]:
    # look for lower values of y and add it to the frontier
    if pair[1] < p_front[-1][1] or isclose( pair[1], p_front[-1][1], abs_tol=0.5 ): 
      p_front.append( pair )

  # mark pareto configs in place
  stats['is_pareto'] = False
  for pair in p_front:
    for index, row in stats.iterrows():
      if row['normalized_delay'] == pair[0] and row['normalized_yaxis'] == pair[1]:
        stats.set_value(index,'is_pareto',True)
  return stats

#-------------------------------------------------------------------------
# normalize_results
#-------------------------------------------------------------------------

def normalize_results( df, base_df, runtime, total_yaxis ):
  base_cfg = g_mimd_base_str % runtime
  for app in app_list:
    try:
      base_steps = float(base_df.loc[(base_df.app == app) & (base_df.config == base_cfg), 'steps'].iloc[0])
      df.loc[(df.app==app) & df.config.str.contains(runtime), 'normalized_delay'] = \
        df.loc[(df.app==app) & df.config.str.contains(runtime), 'normalized_delay'] / base_steps

      base_yaxis = float(base_df.loc[(base_df.app == app) & (base_df.config == base_cfg), total_yaxis].iloc[0])
      df.loc[(df.app==app) & df.config.str.contains(runtime), 'normalized_yaxis'] = \
        df.loc[(df.app==app) & df.config.str.contains(runtime), 'normalized_yaxis'] * 100/ base_yaxis
    except:
      continue
  return df    

#-------------------------------------------------------------------------
# main
#-------------------------------------------------------------------------

if __name__ == "__main__":
  # parse options
  opts = parse_cmdline()
  
  # get the runtime
  runtime = opts.runtime

  # read the results
  all_results = pd.read_csv( "sim-l0-results.csv" )

  # skip non-zero values which indicate missing data
  all_results = all_results[all_results!=0]

  # add new columns
  all_results['normalized_delay'] = all_results['steps']
  all_results['normalized_yaxis'] = all_results['unique_iaccess']

  # baseline mimd results are present in a different file
  base_df = pd.read_csv( g_sim_results_file )

  # populate all the configs
  configs_dict = populate_optimal_configs( runtime )

  # get the dataframe of interest
  df = all_results[all_results.config.isin( configs_dict.values() )].copy()

  # get normalized results
  df = normalize_results( df, base_df, runtime, 'total_iaccess' )

  # determine the apps
  kernels_list = []
  if   runtime == "spmd":
    kernels_list += app_custom_list
    kernels_list += app_pbbs_list
  elif runtime == "wsrt":
    kernels_list += app_custom_list
    kernels_list += app_pbbs_list
    kernels_list += app_cilk_list

  pareto_frame = pd.DataFrame(columns=['app']+configs_dict.keys())
  for app in kernels_list:
    try:
      # get the subframe
      stats = df.loc[df.app==app].copy()
      stats = stats.round(1)
      # update stats with a pareto optimal column 
      stats = pareto_frontier( stats['normalized_delay'].values.tolist(), stats['normalized_yaxis'].values.tolist(), stats )
      # populate the table entries
      pareto_list = []
      for cfg in configs_dict.itervalues():
        pareto = stats.loc[(stats.config==cfg),'is_pareto'].values[0] 
        pareto = "\cellcolor{cbxgreenA}" if pareto else "\cellcolor{white}"
        delay = stats.loc[(stats.config==cfg),'normalized_delay'].values[0] 
        yaxis = stats.loc[(stats.config==cfg),'normalized_yaxis'].values[0] 
        # only for mis 2-imem+llfu
        if not math.isnan( delay ):
          pareto_list.append( pareto + " ({:4.2f},{:5.2f})".format(delay,yaxis) )
        else:
          pareto_list.append( "" )
      pareto_frame = pareto_frame.append( pd.Series([app] + pareto_list, index=pareto_frame.columns),ignore_index=True )
      # DEBUG prints
      print app
      for name,cfg in configs_dict.iteritems():
        delay   = stats.loc[(stats.config == cfg), 'normalized_delay'].iloc[0]
        yaxis   = stats.loc[(stats.config == cfg), 'normalized_yaxis'].iloc[0]
        optimal = stats.loc[(stats.config == cfg), 'is_pareto' ].iloc[0]
        print "{:15s} {:5s} {:f} {:f}".format( name, str(optimal), delay, yaxis )
      print
    except:
      continue

  with open( 'tbl-pareto-table-%s.tex' % runtime, 'w' ) as out:
    out.write( "\\begin{table}\n" )
    out.write( "\centering\n" )
    out.write( "\\scalebox{0.8}{\cbxcaptionsize\n" )
    out.write( "\\tabcolsep 2.0pt\n" )
    out.write( "\\renewcommand\\tabcolsep{4pt}\n" )
    out.write( pareto_frame.to_latex(index=False,encoding='str') )
    out.write( "}\n" )
    out.write( "\caption[Test table]{Test Table}\n" )
    out.write( "\label{tbl-pareto-table-%s}\n" % runtime )
    out.write( "\end{table}" )
