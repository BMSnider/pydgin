#!/usr/bin/env python
#=========================================================================
# pareto-table [options]
#=========================================================================
#
#  -h --help          Display this message
#
#  --runtime          Select runtime
#                       [spmd,wsrt]
#
# Author : Shreesha Srinath
# Date   : March 12th, 2018
#
# For all the static configurations pick the optimal set of knobs and try
# to spit out a table or plot

import argparse
import re
import math
import sys

import pandas as pd
pd.set_option('display.width', 1000)

import brg_plot

from collections import OrderedDict

from common import *
from common_configs import *

#-------------------------------------------------------------------------
# Command line processing
#-------------------------------------------------------------------------

class ArgumentParserWithCustomError(argparse.ArgumentParser):
  def error( self, msg = "" ):
    if ( msg ): print("\n ERROR: %s" % msg)
    print("")
    file = open( sys.argv[0] )
    for ( lineno, line ) in enumerate( file ):
      if ( line[0] != '#' ): sys.exit(msg != "")
      if ( (lineno == 2) or (lineno >= 4) ): print( line[1:].rstrip("\n") )

def parse_cmdline():
  p = ArgumentParserWithCustomError( add_help=False )

  # Standard command line arguments

  p.add_argument( "-h", "--help",    action="store_true" )

  # Additional commane line arguments for the simulator

  p.add_argument( "--runtime", action="store", default="spmd",
                  choices=["spmd", "wsrt"])

  opts = p.parse_args()
  if opts.help: p.error()
  return opts

#-------------------------------------------------------------------------
# global variables
#-------------------------------------------------------------------------

g_ccores_cfg_prefix = "conj-cores-%s"
g_simt_cfg_prefix   = "simt-%s"
g_cfg_str           = "-%dL0-%dI-%dF-%dL-%dC-%dTS-%dLO-%d-%dLL-%dAH"

g_short_cfg_names = [
  "1 imem",
  "2 imem",
  "1 imem+fe",
  "2 imem+fe",
  "1 imem+llfu",
  "2 imem+llfu",
  "1 imem+fe+llfu",
  "2 imem+fe+llfu",
  "share all",
]

#-------------------------------------------------------------------------
# populate_optimal_configs
#-------------------------------------------------------------------------

def populate_optimal_configs( runtime ):
  max_resources  = 4
  limit_lockstep = 0
  adaptive_hint  = 0
  l0_buffer_sz   = 1
  coalescing     = 1
  barrier_limit  = 1000

  configs_list = []

  # imem configs: l0 + coalesce + rr + hint (na: lockstep)
  analysis = 0
  lockstep = 0
  for insn_ports in [1,2]:
    cfg  = g_ccores_cfg_prefix % ( runtime )
    cfg += g_cfg_str % ( 
            l0_buffer_sz,
            insn_ports,
            max_resources,
            max_resources,
            coalescing,
            analysis,
            lockstep,
            barrier_limit,
            limit_lockstep,
            adaptive_hint
           )
    configs_list.append( cfg )

  # imem+fe configs: l0 + min-pc + hint (na: coalescing, lockstep) 
  analysis = 1 
  lockstep = 1
  for frontend in [1,2]:
    cfg  = g_simt_cfg_prefix % ( runtime )
    cfg += g_cfg_str % ( 
            l0_buffer_sz,
            frontend,
            frontend,
            max_resources,
            coalescing,
            analysis,
            lockstep,
            barrier_limit,
            limit_lockstep,
            adaptive_hint
           )
    configs_list.append( cfg )

  # imem+llfu configs: l0 + coalesce + rr + hint
  analysis = 0
  lockstep = 1
  for resources in [1,2]:
    cfg  = g_ccores_cfg_prefix % ( runtime )
    cfg += g_cfg_str % ( 
            l0_buffer_sz,
            resources,
            max_resources,
            resources,
            coalescing,
            analysis,
            lockstep,
            barrier_limit,
            limit_lockstep,
            adaptive_hint
           )
    configs_list.append( cfg )

  # imem+fe+llfu configs: l0 + min-pc + hint (na: coalescing, lockstep) 
  analysis = 1 
  lockstep = 1
  for resources in [1,2]:
    cfg  = g_simt_cfg_prefix % ( runtime )
    cfg += g_cfg_str % ( 
            l0_buffer_sz,
            resources,
            resources,
            resources,
            coalescing,
            analysis,
            lockstep,
            barrier_limit,
            limit_lockstep,
            adaptive_hint
           )
    configs_list.append( cfg )

  # share everything
  mt_cfg_prefix = "mt-%s"
  mt_cfg_str    = "-%dTS-%d-%dAH"
  for analysis in [0,1]:  
    cfg  = mt_cfg_prefix % ( runtime )
    cfg += mt_cfg_str % (
            analysis,
            barrier_limit,
            adaptive_hint  
           )
    configs_list.append( cfg )

  configs_dict = OrderedDict( zip( g_short_cfg_names, configs_list ) )
  return configs_dict

#-------------------------------------------------------------------------
# is_pareto_front()
#-------------------------------------------------------------------------

def is_pareto_front(row, stats, xlabel, ylabel):
  x = row[xlabel]
  y = row[ylabel]

  # look for points with the same y value but smaller x value
  is_min_x = stats.loc[stats[ylabel]==y].max()[xlabel] >= x
  # look for points with the same x value but smaller y value
  is_min_y = stats.loc[stats[xlabel]==x].max()[ylabel] >= y

  # look for points that are smaller in both x and y
  is_min_xy = len(stats.loc[(stats[xlabel]<x) & (stats[ylabel]<y)])==0

  return is_min_x and is_min_y and is_min_xy

#-------------------------------------------------------------------------
# get_pareto_data()
#-------------------------------------------------------------------------

def get_pareto_data( frame_data ):  
  columns=['config','app','delay','yaxis']
  stats = pd.DataFrame(frame_data,columns=columns)  
  is_pareto = stats.apply(lambda row: is_pareto_front(row, stats, 'delay', 'yaxis'), axis=1)
  pareto_data = stats.loc[is_pareto].sort_values(by='delay')
  return [pareto_data['delay'].values, pareto_data['yaxis'].values]

#-------------------------------------------------------------------------
# normalize_results
#-------------------------------------------------------------------------

def normalize_results( df, base_df, runtime, total_yaxis ):
  base_cfg = g_mimd_base_str % runtime
  for app in app_list:
    try:
      base_steps = float(base_df.loc[(base_df.app == app) & (base_df.config == base_cfg), 'steps'].iloc[0])
      df.loc[(df.app==app) & df.config.str.contains(runtime), 'normalized_delay'] = \
        df.loc[(df.app==app) & df.config.str.contains(runtime), 'normalized_delay'] / base_steps

      base_yaxis = float(base_df.loc[(base_df.app == app) & (base_df.config == base_cfg), total_yaxis].iloc[0])
      df.loc[(df.app==app) & df.config.str.contains(runtime), 'normalized_yaxis'] = \
        df.loc[(df.app==app) & df.config.str.contains(runtime), 'normalized_yaxis'] * 100/ base_yaxis
    except:
      continue
  return df    

#-------------------------------------------------------------------------
# main
#-------------------------------------------------------------------------

if __name__ == "__main__":
  # parse options
  opts = parse_cmdline()
  
  # get the runtime
  runtime = opts.runtime

  # read the results
  all_results = pd.read_csv( g_sim_results_file )

  # skip non-zero values which indicate missing data
  all_results = all_results[all_results!=0]

  # add new columns
  all_results['normalized_delay'] = all_results['steps']
  all_results['normalized_yaxis'] = all_results['unique_iaccess']

  # baseline mimd results are present in a different file
  base_df = pd.read_csv( g_sim_results_file )

  # populate all the configs
  configs_dict = populate_optimal_configs( runtime )

  # get the dataframe of interest
  df = all_results[all_results.config.isin( configs_dict.values() )].copy()

  # get normalized results
  df = normalize_results( df, base_df, runtime, 'total_iaccess' )

  # determine the apps
  kernels_list = []
  if   runtime == "spmd":
    kernels_list += app_custom_list
    kernels_list += app_pbbs_list
  elif runtime == "wsrt":
    kernels_list += app_custom_list
    kernels_list += app_pbbs_list
    kernels_list += app_cilk_list

  pareto_frame = pd.DataFrame(columns=['app']+configs_dict.keys())
  for app in kernels_list:
    try:
      # get the subframe
      stats = df.loc[df.app==app].copy()
      # get the series which indicates pareto optimality
      stats['is_pareto'] = stats.apply(lambda row: is_pareto_front(row, stats, 'normalized_delay', 'normalized_yaxis'), axis=1)
      pareto_list = []
      for cfg in configs_dict.itervalues():
        pareto = stats.loc[(stats.config==cfg),'is_pareto'].values[0] 
        pareto = "\checkmark" if pareto else ""
        pareto_list.append( pareto )
      pareto_frame = pareto_frame.append( pd.Series([app] + pareto_list, index=pareto_frame.columns),ignore_index=True )
      # DEBUG prints
      #print app
      #for name,cfg in configs_dict.iteritems():
      #  delay   = stats.loc[(stats.config == cfg), 'normalized_delay'].iloc[0]
      #  yaxis   = stats.loc[(stats.config == cfg), 'normalized_yaxis'].iloc[0]
      #  optimal = stats.loc[(stats.config == cfg), 'is_pareto' ].iloc[0]
      #  print "{:15s} {:5s} {:f} {:f}".format( name, str(optimal), delay, yaxis )
      #print
    except:
      continue

  print "\\begin{table}"
  print "\centering"
  print "{\cbxcaptionsize"
  print "\\tabcolsep 2.0pt"
  print "\\renewcommand\\tabcolsep{4pt}"
  print pareto_frame.to_latex(index=False,encoding='str')
  print "}"
  print "\caption[Test table]{Test Table}" 
  print "\label{tbl-test}"
  print "\end{table}"
