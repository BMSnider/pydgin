#!/usr/bin/env python
#=========================================================================
# tpa-simt-static-dsa [options]
#=========================================================================
#
#  -h --help           Display this message
#
#  --g_ncores          Number of cores
#  --g_insn_ports      Number of instruction ports
#  --g_resources       Number of backend resources
#  --speedup           Select speedup or execution time (default exec time)
#  --savings           Select savings or work (default work)
#  --spmd              Select spmd data-points 
#  --wsrt              Select wsrt data-points
#  --pareto-frontier   Add a pareto-frontier
#
# Author : Shreesha Srinath
# Date   : February 19th, 2018
#
# Script creates scatter subplots for all the configurations where all
# knobs are varied for a given static configuration. Currently, care only
# about per app plot
#

import argparse
import re
import math
import sys

import pandas as pd

import brg_plot

from common import *
from process_data import *

#-------------------------------------------------------------------------
# Command line processing
#-------------------------------------------------------------------------

class ArgumentParserWithCustomError(argparse.ArgumentParser):
  def error( self, msg = "" ):
    if ( msg ): print("\n ERROR: %s" % msg)
    print("")
    file = open( sys.argv[0] )
    for ( lineno, line ) in enumerate( file ):
      if ( line[0] != '#' ): sys.exit(msg != "")
      if ( (lineno == 2) or (lineno >= 4) ): print( line[1:].rstrip("\n") )

def parse_cmdline():
  p = ArgumentParserWithCustomError( add_help=False )

  # Standard command line arguments

  p.add_argument( "-h", "--help",    action="store_true" )

  # Additional commane line arguments for the simulator

  p.add_argument( "--g_ncores",     type=int, action="store", default=4)
  p.add_argument( "--g_insn_ports", type=int, action="store", default=1)
  p.add_argument( "--g_resources",  type=int, action="store", default=1)

  p.add_argument( "--speedup",         action="store_true",  default=False )
  p.add_argument( "--savings",         action="store_true",  default=False )
  p.add_argument( "--spmd",            action="store_true",  default=False )
  p.add_argument( "--wsrt",            action="store_true",  default=False )
  p.add_argument( "--pareto-frontier", action="store_true",  default=False )

  opts = p.parse_args()
  if opts.help: p.error()
  return opts

#-------------------------------------------------------------------------
# Global variables
#-------------------------------------------------------------------------

# Will vary based on the static configuration in question and ccores vs. simt
g_ncores       = 4
g_insn_ports   = 1
g_resources    = 4

g_base_str     = "1L0-%dI-%dF-%dL-1C-0TS-1LO-1-0LL-0AH" % ( g_insn_ports, g_insn_ports, g_resources )
g_config_str   = "1L0-%dI-%dF-%dL-1C-%dTS-1LO-%d-0LL-%dAH"

g_config_list  = []
g_stack_labels = ['imem', 'frontend', 'dmem', 'backend']

g_labels = [
  "rr-no-hint",
  "rr-hint",
  "rr-hint-ah",
  "mpc-no-hint",
  "mpc-hint",
  "mpc-hint-ah",
]

#-------------------------------------------------------------------------
# populate_configs()
#-------------------------------------------------------------------------

def populate_configs( insn_ports, resources ):
  config_list = []
  for analysis in [0,1]:
    for barrier_limit in [1,1000]:
      for adaptive_hint in range( 2 ):
        if barrier_limit == 1 and adaptive_hint == 1:
          continue
        config_str = g_config_str % (
          insn_ports,
          insn_ports,
          resources,
          analysis,
          barrier_limit,
          adaptive_hint
        )
        config_list.append( config_str )
  return config_list

#-------------------------------------------------------------------------
# is_pareto_front()
#-------------------------------------------------------------------------
# reference:
# http://hinnefe2.github.io/python/tools/2015/09/21/mario-kart.html

def is_pareto_front(row, stats, xlabel, ylabel):
  x = row[xlabel]
  y = row[ylabel]
  # look for points with the same y value but larger x value
  is_max_x = stats.loc[stats[ylabel]==y].max()[xlabel] <= x
  # look for points with the same x value but larger y value
  is_max_y = stats.loc[stats[xlabel]==x].max()[ylabel] <= y
  # look for points that are larger in both x and y
  is_double = len(stats.loc[(stats[xlabel]>x) & (stats[ylabel]>y)])==0
  return is_max_x and is_max_y and is_double

#-------------------------------------------------------------------------
# plot_per_app()
#-------------------------------------------------------------------------
# NOTE: Each data-point is a list of lists where each nested list
# represents a unique configuration and each configuration list is in turn
# a nested list of x,y points for the scatter plot
#
# Example:
#  data = [
#    [[1,1],[2,2]], # group 1
#    [[3,3],[4,4]], # group 2
#   ]

def plot_per_app( savings_label, speedup_label, prefix_str, app, opts, df, pareto_frontier=False ):

  opts.num_cols = 2
  opts.num_rows = 1

  index   = 0
  data    = []
  stats   = pd.DataFrame()
  x_label = 'steps'
  y_label = 'total'
  for config in g_config_list:
    try:
      speedup = df[(df.config == config) & (df.app == app)].iloc[0][x_label]
      savings = df[(df.config == config) & (df.app == app)].iloc[0][y_label]
      data.append( [[speedup, savings]] )
      if pareto_frontier:
        stats = stats.append( df.loc[(df.config == config) & (df.app == app), ['config', x_label, y_label]] )
    except:
      data.append( [[float('nan')]*2] )

  # first add the scatter plot
  opts.xrange         = [0.3,1.5]
  opts.yrange         = [0,100]
  opts.data           = data
  opts.labels         = [[],g_labels]
  opts.rotate_labels  = True
  opts.plot_idx       = index+1
  opts.colors         = brg_plot.colors['unique20']
  opts.pareto_points  = pareto_frontier
  if pareto_frontier:
    is_pareto = stats.apply(lambda row: is_pareto_front(row, stats, x_label, y_label),axis=1)
    config_pareto = stats.ix[is_pareto].sort_values(by=x_label)
    opts.pareto_data = [config_pareto[x_label].values, config_pareto[y_label].values]
  opts.legend_enabled  = True
  opts.legend_ncol     = 2

  if savings_label and speedup_label:
    opts.ylabel = 'Work Savings(%)'
    opts.xlabel = 'Speedup'
  elif not savings_label and speedup_label:
    opts.ylabel = 'Work (%)'
    opts.xlabel = 'Speedup'
  elif savings_label and not speedup_label:
    opts.ylabel = 'Work Savings(%)'
    opts.xlabel = 'Norm. Steps'
  elif not savings_label and not speedup_label:
    opts.ylabel = 'Work (%)'
    opts.xlabel = 'Norm. Steps'

  # plot data
  brg_plot.add_plot( opts )
  index = index + 1

  # plot the bar plot now
  data = []
  for config in g_config_list:
    temp = []
    try:
      for stack_label in g_stack_labels:
        temp.append( df[(df.config == config) & (df.app == app)].iloc[0][stack_label] )
      data.append( temp )
    except:
      data.append( [float('nan')]*5 )

  opts.xrange          = None
  opts.plot_type       = 'stacked_bar'
  opts.bar_width       = 0.5
  opts.data            = data
  opts.ncol            = 3
  opts.labels          = [g_labels,g_stack_labels]
  opts.rotate_labels   = True
  opts.colors          =  [ '#616161', '#ffffcc', '#8aae92', '#3f6699', '#113c4a' ]
  opts.plot_idx        = index + 1
  opts.file_name       = '%(app)s-simt.pdf' % { 'app' : app }
  opts.xlabel          = None
  opts.subplots_hspace = 0.5
  opts.fig.text(0.5, 1.20, app, ha='center', fontsize=14)
  
  # plot data
  brg_plot.add_plot( opts )


#-------------------------------------------------------------------------
# plot
#-------------------------------------------------------------------------

def plot( savings, speedup, df, prefix_str, pareto_frontier ):

  apps = df.app.unique()
  for app in  apps:
    if app not in app_list:
      continue
    # create plot options dict
    opts = brg_plot.PlotOptions()
    attribute_dict = \
    {
      'show'            : False,
      'plot_type'       : 'scatter',
      'figsize'         : (8.0, 4.0),
      'rotate_labels'   : False,
      'markersize'      : 50,
      'labels_fontsize' : 1,
      'legend_enabled'  : False,
    }
    for name, value in attribute_dict.iteritems():
      setattr( opts, name, value )

    plot_per_app( savings, speedup, prefix_str, app, opts, df, pareto_frontier )

#-------------------------------------------------------------------------
# main
#-------------------------------------------------------------------------

if __name__ == "__main__":
  opts = parse_cmdline()

  g_ncores     = opts.g_ncores
  g_insn_ports = opts.g_insn_ports
  g_resources  = opts.g_resources

  # select spmd vs. wsrt
  # NOTE: change this based on ccors vs. simt
  prefix_str = ""
  if opts.spmd:
    prefix_str = 'simt-spmd-' 
  elif opts.wsrt:
    prefix_str = 'simt-wsrt-'
  else:
    print "Select spmd or wsrt!"
    exit(1)

  g_base_str = "1L0-%dI-%dF-%dL-1C-0TS-1LO-1-0LL-0AH" % ( g_insn_ports, g_insn_ports, g_resources )

  # depending on spmd vs. wsrt options select the configurations
  g_config_list = populate_configs( g_insn_ports, g_resources )
  g_config_list = [ prefix_str + cfg for cfg in g_config_list ]

  # process the raw data for the subset of config list
  df = process_data( prefix_str, g_base_str, g_config_list, opts.speedup, opts.savings )

  # option to show the pareto frontier
  pareto_frontier = opts.pareto_frontier

  # create plots
  plot( opts.savings, opts.speedup,  df, prefix_str, pareto_frontier )
