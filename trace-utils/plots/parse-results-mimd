#!/usr/bin/env python
#=========================================================================
# parse-results-mimd
#=========================================================================
#
#  -h --help           Display this message
#
#  --no-spmd           Turn off spmd data-points
#  --no-wsrt           Turn off wsrt data-points
#  --no-perf           Turn off performance normalization
#
# Author : Shreesha Srinath
# Date   : January 18th, 2018
#
# Quick and dirty script to parse results for wsrt similarity on the
# abstract MIMD architecture
#

import argparse
import os
import sys
import re
import subprocess

import pandas as pd

from collections import OrderedDict

#-------------------------------------------------------------------------
# Utility Function
#-------------------------------------------------------------------------

def execute(cmd):
  try:
    #print cmd
    return subprocess.check_output(cmd, shell=True)
  except  subprocess.CalledProcessError, err:
    return err

#-------------------------------------------------------------------------
# Command line processing
#-------------------------------------------------------------------------

class ArgumentParserWithCustomError(argparse.ArgumentParser):
  def error( self, msg = "" ):
    if ( msg ): print("\n ERROR: %s" % msg)
    print("")
    file = open( sys.argv[0] )
    for ( lineno, line ) in enumerate( file ):
      if ( line[0] != '#' ): sys.exit(msg != "")
      if ( (lineno == 2) or (lineno >= 4) ): print( line[1:].rstrip("\n") )

def parse_cmdline():
  p = ArgumentParserWithCustomError( add_help=False )

  # Standard command line arguments

  p.add_argument( "-h", "--help", action="store_true" )

  # Additional commane line arguments for the simulator

  p.add_argument( "--no-spmd",   action="store_false", default=True  )
  p.add_argument( "--no-wsrt",   action="store_false", default=True  )
  p.add_argument( "--no-perf",   action="store_false", default=True  )

  opts = p.parse_args()
  if opts.help: p.error()
  return opts

#-------------------------------------------------------------------------
# Global variable
#-------------------------------------------------------------------------

# map showing the shorter names used.
# NOTE: This data-structure is an OrderedDict which means the order here
# determines the order of all the plots
app_short_name_dict = OrderedDict([
  ('bilateral',                     'bilateral'),
  ('dct8x8m',                       'dct8x8m'),
  ('dither',                        'dither'),
  ('mriq',                          'mriq'),
  ('rgb2cmyk',                      'rgb2cmyk'),
  ('strsearch',                     'strsearch'),
  ('viterbi',                       'viterbi'),
  ('uts',                           'uts'),
  ('pbbs-bfs-deterministicBFS'    , 'bfs-d'),
  ('pbbs-bfs-ndBFS'               , 'bfs-nd'),
  ('pbbs-dict-deterministicHash'  , 'dict'),
  #('pbbs-knn-octTree2Neighbors'   , 'knn'),
  ('pbbs-mis-ndMIS'               , 'mis'),
  #('pbbs-nbody-parallelBarnesHut' , 'nbody'),
  ('pbbs-rdups-deterministicHash' , 'rdups'),
  ('pbbs-sa-parallelRange'        , 'sarray'),
  ('pbbs-st-ndST'                 , 'sptree'),
  #('pbbs-isort-blockRadixSort'    , 'radix-1'),
  #('pbbs-isort-blockRadixSort-1'  , 'radix-2'),
  ('pbbs-csort-quickSort'         , 'qsort'),
  ('pbbs-csort-quickSort-1'       , 'qsort-1'),
  ('pbbs-csort-quickSort-2'       , 'qsort-2'),
  ('pbbs-csort-sampleSort'        , 'sampsort'),
  ('pbbs-csort-sampleSort-1'      , 'sampsort-1'),
  ('pbbs-csort-sampleSort-2'      , 'sampsort-2'),
  ('pbbs-hull-quickHull'          , 'hull'),
  #('cilk-cholesky'                , 'clsky'),
  ('cilk-cilksort'                , 'cilksort'),
  ('cilk-heat'                    , 'heat'),
  ('cilk-knapsack'                , 'ksack'),
  ('cilk-matmul'                  , 'matmul'),
])

g_resultsdir_path = "../results-%s-similarity-limit-%d"

#-------------------------------------------------------------------------
# summarize
#-------------------------------------------------------------------------

def summarize(runtime):

  data = []
  #for limit in [1,50,100,250,500,1000]:
  for limit in [1,250]:
    resultsdir_path = g_resultsdir_path % ( runtime, limit )
    subfolders = os.listdir( resultsdir_path )
    for subfolder in subfolders:
      try:
        app = re.sub("-parc", '', subfolder)
        app = re.sub("-small", '', app)
        app = re.sub("-mtpull", '', app)
        app = re.sub("-mt", '', app)

        if not app in app_short_name_dict.keys():
          continue

        res_file =  resultsdir_path + '/' + subfolder + '/' + subfolder + '.out'
        cmd = 'grep -r -A 35 "Serial steps in stats region =" %(res_file)s' % { 'res_file' : res_file }
        lines = execute( cmd )
        total = 0
        isavings = 0
        for line in lines.split('\n'):
          if line != '':
            if 'Total steps' in line:
              total = int(line.split()[-1])
            elif 'Redundancy in parallel regions' in line:
              isavings = line.split()[-1]

        config = "%s-mimd-limit-%d" % ( runtime, limit )
        data.append([app_short_name_dict[app],config,total,isavings])
      except:
        print "{} limit-{} {}: Results file not present".format( runtime, limit, subfolder )
        continue

  columns = ['app','config','steps','isavings']
  df = pd.DataFrame(data,columns=columns)
  return df

#-------------------------------------------------------------------------
# print table
#-------------------------------------------------------------------------

def print_table( df, base_df, print_perf=True ):
  for app in app_short_name_dict.values():
    if app in base_df.app.unique():
      ts = base_df.loc[base_df.app == app,['steps']].iloc[0]
      df.loc[df.app == app, ['steps']] = \
        float(ts)/df.loc[df.app == app, ['steps']]

  configs = df.config.unique()
  print "{:^21s}".format("kernel") + ("{:^21s}"*len(configs)).format(*configs)
  for app in app_short_name_dict.values():
    if app in base_df.app.unique():
      out = "{:^18s}".format(app)
      for config in configs:
        red  = df.loc[(df.app == app) & (df.config == config), ['isavings']].iloc[0]
        if print_perf:
          perf = df.loc[(df.app == app) & (df.config == config), ['steps']].iloc[0]
          out += "{:^10.2f} {:^10.2f}".format( float(perf), float(red) )
        else:
          out += "{:^20.2f}".format( float(red) )
      print out

#-------------------------------------------------------------------------
# main
#-------------------------------------------------------------------------

if __name__ == "__main__":
  opts = parse_cmdline()

  spmd_df = summarize("spmd")
  wsrt_df = summarize("wsrt")

  if not opts.no_wsrt:
    df = spmd_df
    base_df = df[df.config == "spmd-mimd-limit-1"].copy()
    print_table( df, base_df, opts.no_perf )
  elif not opts.no_spmd:
    df = wsrt_df
    base_df = df[df.config == "wsrt-mimd-limit-1"].copy()
    print_table( df, base_df, opts.no_perf )
  else:
    df = pd.concat([spmd_df,wsrt_df])
    base_df = df[df.config == "spmd-mimd-limit-1"].copy()
    print_table( df, base_df, opts.no_perf )
