#!/usr/bin/env python
#=========================================================================
# tpa-simt-dsa [options]
#=========================================================================
#
#  -h --help           Display this message
#
#  --g_ncores          Number of cores
#  --g_insn_ports      Number of instruction ports
#  --g_resources       Number of backend resources
#  --speedup           Select speedup or execution time (default exec time)
#  --savings           Select savings or work (default work)
#  --spmd              Select spmd data-points 
#  --wsrt              Select wsrt data-points
#  --pareto-frontier   Add a pareto-frontier
#
# Author : Shreesha Srinath
# Date   : February 19th, 2018
#
# Script creates scatter subplots for all the configurations where all
# knobs are varied for a given configuration. Currently, care only
# about per app plot
#

import argparse
import re
import math
import sys

import pandas as pd

import brg_plot

from common import *
from process_data import *

#-------------------------------------------------------------------------
# Command line processing
#-------------------------------------------------------------------------

class ArgumentParserWithCustomError(argparse.ArgumentParser):
  def error( self, msg = "" ):
    if ( msg ): print("\n ERROR: %s" % msg)
    print("")
    file = open( sys.argv[0] )
    for ( lineno, line ) in enumerate( file ):
      if ( line[0] != '#' ): sys.exit(msg != "")
      if ( (lineno == 2) or (lineno >= 4) ): print( line[1:].rstrip("\n") )

def parse_cmdline():
  p = ArgumentParserWithCustomError( add_help=False )

  # Standard command line arguments

  p.add_argument( "-h", "--help",    action="store_true" )

  # Additional commane line arguments for the simulator

  p.add_argument( "--g_ncores",     type=int, action="store", default=4)
  p.add_argument( "--g_insn_ports", type=int, action="store", default=1)
  p.add_argument( "--g_resources",  type=int, action="store", default=1)

  p.add_argument( "--speedup",         action="store_true",  default=False )
  p.add_argument( "--savings",         action="store_true",  default=False )
  p.add_argument( "--spmd",            action="store_true",  default=False )
  p.add_argument( "--wsrt",            action="store_true",  default=False )
  p.add_argument( "--pareto-frontier", action="store_true",  default=False )

  opts = p.parse_args()
  if opts.help: p.error()
  return opts

#-------------------------------------------------------------------------
# Global variables
#-------------------------------------------------------------------------

# Will vary based on the configuration in question and ccores vs. simt
g_ncores       = 4
g_insn_ports   = 1
g_resources    = 2

g_base_str     = "1L0-%dI-%dF-%dL-1C-0TS-1LO-1-0LL-0AH" % ( g_insn_ports, g_insn_ports, g_resources )
g_config_str   = "1L0-%dI-%dF-%dL-1C-%dTS-1LO-%d-%dLL-%dAH"

g_config_list  = []
g_stack_labels = ['imem', 'frontend', 'dmem', 'backend']

#-------------------------------------------------------------------------
# populate_configs()
#-------------------------------------------------------------------------

def populate_configs( insn_ports, resources ):
  config_list = []
  for limit_lockstep in range( 2 ):
    for analysis in [0,1]:
      for adaptive_hint in range( 2 ):
        for barrier_limit in [1,1000]:
          config_str = g_config_str % (
            insn_ports,
            insn_ports,
            resources,
            analysis,
            barrier_limit,
            limit_lockstep,
            adaptive_hint
          )
          config_list.append( config_str )
  return config_list

#-------------------------------------------------------------------------
# is_pareto_front()
#-------------------------------------------------------------------------
# reference:
# http://hinnefe2.github.io/python/tools/2015/09/21/mario-kart.html

def is_pareto_front(row, stats, xlabel, ylabel):
  x = row[xlabel]
  y = row[ylabel]
  # look for points with the same y value but larger x value
  is_max_x = stats.loc[stats[ylabel]==y].max()[xlabel] <= x
  # look for points with the same x value but larger y value
  is_max_y = stats.loc[stats[xlabel]==x].max()[ylabel] <= y
  # look for points that are larger in both x and y
  is_double = len(stats.loc[(stats[xlabel]>x) & (stats[ylabel]>y)])==0
  return is_max_x and is_max_y and is_double

#-------------------------------------------------------------------------
# subsample_configs
#-------------------------------------------------------------------------

def subsample_configs( prefix_str, analysis ):
  configs = []

  for limit_lockstep in [0,1]:
    for barrier_limit in [1,1000]:
      for adaptive_hint in range( 2 ):
        if adaptive_hint == 1 and barrier_limit == 1:
          continue
        if g_resources == 1 and limit_lockstep == 1:  
          continue
        config_str = prefix_str + g_config_str % (
          g_insn_ports,
          g_insn_ports,
          g_resources,
          analysis,
          barrier_limit,
          limit_lockstep,
          adaptive_hint
        )
        configs.append( config_str )
  return configs

g_labels = []
g_labels_list = [
  [
    "no-hint",
    "hint",
    "hint-ah",
    "no-hint-lim",
    "hint-lim",
    "hint-ah-lim",
  ],
  [
    "no-hint",
    "hint",
    "hint-ah",
  ]
]

#-------------------------------------------------------------------------
# plot_per_app()
#-------------------------------------------------------------------------
# NOTE: Each data-point is a list of lists where each nested list
# represents a unique configuration and each configuration list is in turn
# a nested list of x,y points for the scatter plot
#
# Example:
#  data = [
#    [[1,1],[2,2]], # group 1
#    [[3,3],[4,4]], # group 2
#   ]

def plot_per_app( savings_label, speedup_label, prefix_str, app, opts, df, pareto_frontier=False ):

  opts.num_cols = 2
  opts.num_rows = 2

  # select a set of configs
  index = 1
  for analysis in range( 2 ):
    configs = subsample_configs( prefix_str, analysis )

    # 1. plot the scatter plot
    data    = []
    stats   = pd.DataFrame()
    x_label = 'steps'
    y_label = 'total'
    for config in configs:
      try:
        speedup = df[(df.config == config) & (df.app == app)].iloc[0][x_label]
        savings = df[(df.config == config) & (df.app == app)].iloc[0][y_label]
        data.append( [[speedup, savings]] )
        if pareto_frontier:
          stats = stats.append( df.loc[(df.config == config) & (df.app == app), ['config', x_label, y_label]] )
      except:
        data.append( [[float('nan')]*2] )

    opts.xrange         = [0.5,1.5]
    opts.yrange         = [0,100]
    opts.plot_type      = 'scatter'
    opts.data           = data
    opts.labels         = [[],g_labels]
    opts.rotate_labels  = True
    opts.plot_idx       = index
    opts.colors         = brg_plot.colors['unique20']
    opts.title          = '%s' % ( 'rr' if analysis == 0 else 'mpc' )
    opts.pareto_points  = pareto_frontier
    if pareto_frontier:
      is_pareto = stats.apply(lambda row: is_pareto_front(row, stats, x_label, y_label),axis=1)
      config_pareto = stats.ix[is_pareto].sort_values(by=x_label)
      opts.pareto_data = [config_pareto[x_label].values, config_pareto[y_label].values]

    if index == 1:
      opts.legend_enabled = True
      opts.legend_ncol    = 2
      opts.legend_bbox    = (0,1.1,1.,0.1)
    else:
      opts.legend_enabled = False

    if savings_label and speedup_label:
      opts.ylabel = 'Work Savings(%)'
      opts.xlabel = 'Speedup'
    elif not savings_label and speedup_label:
      opts.ylabel = 'Work (%)'
      opts.xlabel = 'Speedup'
    elif savings_label and not speedup_label:
      opts.ylabel = 'Work Savings(%)'
      opts.xlabel = 'Norm. Steps'
    elif not savings_label and not speedup_label:
      opts.ylabel = 'Work (%)'
      opts.xlabel = 'Norm. Steps'

    # plot data
    brg_plot.add_plot( opts )

    # 2. plot the bar plot
    data    = []
    for config in configs:
      temp = []
      try:
        for stack_label in g_stack_labels:
          temp.append( df[(df.config == config) & (df.app == app)].iloc[0][stack_label] )
        data.append( temp )
      except:
        data.append( [float('nan')]*5 )

    opts.plot_type       = 'stacked_bar'
    opts.bar_width       = 0.5
    opts.data            = data
    opts.labels          = [g_labels,g_stack_labels]
    opts.rotate_labels   = True
    opts.plot_idx        = index + 1
    opts.colors          =  [ '#616161', '#ffffcc', '#8aae92', '#3f6699', '#113c4a' ]
    opts.title           = '%s' % ( 'rr' if analysis == 0 else 'mpc' )
    opts.subplots_hspace = 0.5
    opts.subplots_wspace = 1.0
    opts.xrange          = None

    if index == 1:
      opts.legend_enabled = True
      opts.legend_ncol    = 2
      opts.legend_bbox    = (0,1.1,1.,0.1)
    else:
      opts.legend_enabled = False

    opts.ylabel = None
    opts.xlabel = None

    if index == opts.num_cols*opts.num_rows-1:
      opts.file_name = '%(app)s-simt.pdf' % { 'app' : app }
      opts.fig.text(0.5, 1.1, app, ha='center', fontsize=14)

    # plot data
    brg_plot.add_plot( opts )
    index = index + 2

#-------------------------------------------------------------------------
# plot
#-------------------------------------------------------------------------

def plot( savings, speedup, df, prefix_str, pareto_frontier ):

  apps = df.app.unique()
  for app in  apps:
    if app not in app_list:
      continue
    # create plot options dict
    opts = brg_plot.PlotOptions()
    attribute_dict = \
    {
      'show'            : False,
      'plot_type'       : 'scatter',
      'figsize'         : (8.0, 8.0),
      'rotate_labels'   : False,
      'markersize'      : 50,
      'labels_fontsize' : 1,
      'legend_enabled'  : False,
    }
    for name, value in attribute_dict.iteritems():
      setattr( opts, name, value )

    plot_per_app( savings, speedup, prefix_str, app, opts, df, pareto_frontier )

#-------------------------------------------------------------------------
# main
#-------------------------------------------------------------------------

if __name__ == "__main__":
  opts = parse_cmdline()

  g_ncores     = opts.g_ncores
  g_insn_ports = opts.g_insn_ports
  g_resources  = opts.g_resources

  if g_resources > 1:
    g_labels = g_labels_list[0]
  else:
    g_labels = g_labels_list[1]

  # select spmd vs. wsrt
  # NOTE: change this based on ccors vs. simt
  prefix_str = ""
  if opts.spmd:
    prefix_str = 'simt-spmd-' 
  elif opts.wsrt:
    prefix_str = 'simt-wsrt-'
  else:
    print "Select spmd or wsrt!"
    exit(1)

  g_base_str = "1L0-%dI-%dF-%dL-1C-0TS-1LO-1-0LL-0AH" % ( g_insn_ports, g_insn_ports, g_resources )

  # depending on spmd vs. wsrt options select the configurations
  g_config_list = populate_configs( g_insn_ports, g_resources )
  g_config_list = [ prefix_str + cfg for cfg in g_config_list ]

  # process the raw data for the subset of config list
  df = process_data( prefix_str, g_base_str, g_config_list, opts.speedup, opts.savings )

  # option to show the pareto frontier
  pareto_frontier = opts.pareto_frontier

  # create plots
  plot( opts.savings, opts.speedup,  df, prefix_str, pareto_frontier )
