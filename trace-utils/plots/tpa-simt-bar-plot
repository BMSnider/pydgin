#!/usr/bin/env python
#=========================================================================
# tpa-simt-bar-plot [options]
#=========================================================================
#
#  -h --help          Display this message
#
#  --g_ncores         Number of cores
#  --g_insn_ports     Number of instruction ports
#  --g_resources      Number of backend resources
#  --app-group        Select app-group
#                       [custom,pbbs,cilk]
#  --runtime          Select runtime
#                       [spmd,wsrt]
#
# Author : Shreesha Srinath
# Date   : February 21st, 2018
#
# Bar plots for work vs. steps normalized to mimd configuration for the
# simt configuration

import argparse
import re
import math
import sys

import pandas as pd
pd.set_option('display.width', 100)

import brg_plot

from common import *
from process_data import *

#-------------------------------------------------------------------------
# Command line processing
#-------------------------------------------------------------------------

class ArgumentParserWithCustomError(argparse.ArgumentParser):
  def error( self, msg = "" ):
    if ( msg ): print("\n ERROR: %s" % msg)
    print("")
    file = open( sys.argv[0] )
    for ( lineno, line ) in enumerate( file ):
      if ( line[0] != '#' ): sys.exit(msg != "")
      if ( (lineno == 2) or (lineno >= 4) ): print( line[1:].rstrip("\n") )

def parse_cmdline():
  p = ArgumentParserWithCustomError( add_help=False )

  # Standard command line arguments

  p.add_argument( "-h", "--help",    action="store_true" )

  # Additional commane line arguments for the simulator

  p.add_argument( "--speedup", action="store_true", default=False )
  p.add_argument( "--savings", action="store_true", default=False )

  p.add_argument( "--g_ncores",     type=int, action="store", default=1)
  p.add_argument( "--g_insn_ports", type=int, action="store", default=1)
  p.add_argument( "--g_resources",  type=int, action="store", default=4)

  p.add_argument( "--runtime", action="store", default="spmd",
                  choices=["spmd", "wsrt"])
  p.add_argument( "--app-group", action="store", default="custom",
                  choices=["custom", "pbbs","cilk"])

  opts = p.parse_args()
  if opts.help: p.error()
  return opts

#-------------------------------------------------------------------------
# Global variables
#-------------------------------------------------------------------------
g_ncores       = 4
g_insn_ports   = 1
g_resources    = 1

# NOTE: set these based on the static configuration
g_config_str   = "1L0-%dI-%dF-%dL-%dC-%dTS-%dLO-%d-%dLL-%dAH"

# used for the stack bar plots
g_stacks       = ['unique_daccess', 'unique_execute', 'unique_frontend', 'unique_iaccess']
mimd_stacks    = ['total_daccess', 'total_execute', 'total_frontend', 'total_iaccess']
g_stack_labels = ['dmem', 'backend', 'frontend', 'imem']

# NOTE: set these based on the static configuration
g_cfg_labels = [
  "mimd (a)",
  "1-rr-1c-1l-0h (b)",
  "1-rr-1c-1l-1h (c)",
  "1-pc-1c-1l-0h (d)",
  "1-pc-1c-1l-1h (e)",
  "2-rr-1c-1l-0h (f)",
  "2-rr-1c-1l-1h (g)",
  "2-pc-1c-1l-0h (h)",
  "2-pc-1c-1l-1h (i)",
]

#-------------------------------------------------------------------------
# select_plot_configs()
#-------------------------------------------------------------------------
# NOTE: select configs based on the static configuration
# Function should return a list of configs for the plot script where each
# config is a subcategory of the bar plot

def select_plot_configs( runtime ):
  limit_lockstep = 0  
  adaptive_hint  = 0
  
  config_list = []
  prefix_str  = 'simt-%s-' % runtime

  for resources in [1,2]:
    for analysis in [0,1]: 
      # n-ts-1c-1l-0h
      # n-ts-1c-1l-1h
      for barrier_limit in [1,1000]:
        config_list.append( 
          prefix_str + 
          g_config_str % ( 
            resources, 
            resources, 
            resources, 
            1,              # coalescing
            analysis,       # thread-selection
            1,              # lockstep
            barrier_limit,  # hint
            limit_lockstep,
            adaptive_hint 
          )
        )
  return config_list

#-------------------------------------------------------------------------
# plot
#-------------------------------------------------------------------------

def plot( df, app_group, runtime ):
  # list of apps based on the app group 
  apps = []
  if   app_group == "custom": apps = app_custom_list
  elif app_group == "pbbs"  : apps = app_pbbs_list
  elif app_group == "cilk"  : apps = app_cilk_list
 
  # create plot options dict
  opts = brg_plot.PlotOptions()
  attribute_dict = \
  {
    'show'            : False,
    'plot_type'       : 'bar',
    'figsize'         : (20.0, 8.0),
    'bar_width'       : 0.9,
  }
  for name, value in attribute_dict.iteritems():
    setattr( opts, name, value )

  opts.num_rows = 2
  opts.num_cols = 1

  index = 1
  mimd_cfg_str = 'mimd-%s-1-0AH'
  mimd_cfg    = mimd_cfg_str % runtime
  config_list = select_plot_configs( runtime )

  #---------------------------------------------------------------------
  # 1. plot performance 
  #---------------------------------------------------------------------

  data   = []
  labels = []
  for app in apps: 
    if app not in df.app.unique():
      continue
    temp = [] 
    try:
      # collect the mimd performance first
      mimd_steps = float(df.loc[(df.app == app) & (df.config == mimd_cfg), 'steps'].iloc[0])
      temp.append( mimd_steps / mimd_steps )
      # collect the performance for the configs of interest
      for cfg in config_list:
        cfg_steps = df.loc[(df.app == app) & (df.config == cfg), 'steps'].iloc[0]
        temp.append( cfg_steps / mimd_steps )
      labels.append( app )
      data.append( temp )
    except:
      continue

  opts.plot_type      = 'bar'
  opts.plot_idx       = index
  opts.data           = data
  opts.normalize_line = 1
  opts.rotate_labels  = False
  opts.labels         = [labels, g_cfg_labels]
  opts.legend_ncol    = len( g_cfg_labels )/2 + 1
  opts.legend_enabled = True
  opts.ylabel         = 'Normalized Delay'
  opts.colors         = brg_plot.colors['unique20']

  brg_plot.add_plot( opts )
  index = index + 1

  #---------------------------------------------------------------------
  # 2. plot work 
  #---------------------------------------------------------------------

  # collect the mimd work first
  data   = []
  labels = []
  temp = []
  for app in apps:
    if app not in df.app.unique():
      continue
    try:
      mimd_total = float(df.loc[(df.app == app) & (df.config == mimd_cfg), 'total_work'].iloc[0])
      vals = [] 
      for stack in mimd_stacks:
        vals.append( df.loc[(df.app == app) & (df.config == mimd_cfg), stack].iloc[0] * 100 / mimd_total )
      temp.append(vals)
      labels.append( app )
    except:
      continue
  data.append( temp )
 
  # collect the work for all
  for cfg in config_list:
    temp = [] 
    for app in apps:
      if app not in df.app.unique():
        continue
      try:
        mimd_total = float(df.loc[(df.app == app) & (df.config == mimd_cfg), 'total_work'].iloc[0])
        vals = [] 
        sumv = 0
        for stack in g_stacks:
          vals.append( df.loc[(df.app == app) & (df.config == cfg), stack].iloc[0] * 100 / mimd_total )
          sumv += df.loc[(df.app == app) & (df.config == cfg), stack].iloc[0] * 100 / mimd_total
        temp.append( vals )
      except:
        continue
    data.append( temp )

  opts.plot_idx            = index 
  opts.plot_type           = 'clustered_stacked_bar'
  opts.data                = data
  opts.normalize_line      = None
  opts.rotate_labels       = True
  opts.rotate_labels_angle = 0
  subcat_labels = [chr(i) for i in range(ord('a'),ord('i')+1)]
  opts.labels              = [labels,subcat_labels,g_stack_labels]
  opts.legend_ncol         = len( g_stack_labels )
  opts.legend_enabled      = True
  opts.label_dist          = -15
  opts.ylabel              = 'Normalized Work (%)'
  opts.colors              = ['#616161', '#ffffcc', '#8aae92', '#3f6699', '#113c4a']

  brg_plot.add_plot( opts )

  if index == opts.num_rows * opts.num_cols:
    opts.fig.text( 0.5, 1.1, 
      '%s-%s\nxc-cores-NI-NF-NL' % ( app_group, runtime ), 
      ha='center', fontsize=16
    )
    brg_plot.plt.subplots_adjust(hspace=5)
    brg_plot.plt.tight_layout()
    file_name = '%s-%s-xc-cores-NI-NF-NL.pdf' % ( app_group, runtime )
    brg_plot.plt.savefig( file_name, bbox_inches="tight" )
    print "saving %s" % file_name
  index = index + 1

#-------------------------------------------------------------------------
# main
#-------------------------------------------------------------------------

if __name__ == "__main__":
  # parse command line arguments
  opts         = parse_cmdline()
  g_insn_ports = opts.g_insn_ports
  g_ncores     = opts.g_ncores
  g_resources  = opts.g_resources

  # read the data frame
  df = pd.read_csv( "sim-results.csv" )

  plot( df, opts.app_group, opts.runtime )
