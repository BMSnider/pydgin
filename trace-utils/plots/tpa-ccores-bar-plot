#!/usr/bin/env python
#=========================================================================
# tpa-ccores-bar-plot [options]
#=========================================================================
#
#  -h --help          Display this message
#
#  --g_ncores         Number of cores
#  --g_insn_ports     Number of instruction ports
#  --g_resources      Number of backend resources
#  --app-group        Select app-group
#                       [custom,pbbs,cilk]
#  --runtime          Select runtime
#                       [spmd,wsrt]
#  --component        Select component to be used for stack bar plots
#
# Author : Shreesha Srinath
# Date   : February 21st, 2018
#
# Bar plots for work vs. steps normalized to mimd configuration for the
# ccores configuration

import argparse
import re
import math
import sys

import pandas as pd
pd.set_option('display.width', 100)

import brg_plot

from common import *
from process_data import *

#-------------------------------------------------------------------------
# Command line processing
#-------------------------------------------------------------------------

class ArgumentParserWithCustomError(argparse.ArgumentParser):
  def error( self, msg = "" ):
    if ( msg ): print("\n ERROR: %s" % msg)
    print("")
    file = open( sys.argv[0] )
    for ( lineno, line ) in enumerate( file ):
      if ( line[0] != '#' ): sys.exit(msg != "")
      if ( (lineno == 2) or (lineno >= 4) ): print( line[1:].rstrip("\n") )

def parse_cmdline():
  p = ArgumentParserWithCustomError( add_help=False )

  # Standard command line arguments

  p.add_argument( "-h", "--help",    action="store_true" )

  # Additional commane line arguments for the simulator

  p.add_argument( "--speedup", action="store_true", default=False )
  p.add_argument( "--savings", action="store_true", default=False )

  p.add_argument( "--g_ncores",     type=int, action="store", default=4)
  p.add_argument( "--g_insn_ports", type=int, action="store", default=1)
  p.add_argument( "--g_resources",  type=int, action="store", default=1)

  p.add_argument( "--component", action="store", default='iaccess', 
                  choices=["iaccess","daccess","execute","frontend","mem","work"])
  p.add_argument( "--runtime", action="store", default="spmd",
                  choices=["spmd", "wsrt"])
  p.add_argument( "--app-group", action="store", default="custom",
                  choices=["custom", "pbbs","cilk"])

  opts = p.parse_args()
  if opts.help: p.error()
  return opts

#-------------------------------------------------------------------------
# Global variables
#-------------------------------------------------------------------------
g_ncores       = 4
g_insn_ports   = 1
g_resources    = 1

# NOTE: set these based on the static configuration
g_config_str   = "1L0-%dI-%dF-%dL-%dC-%dTS-%dLO-%d-%dLL-%dAH"

# used for the stack bar plots
g_stacks       = []
g_mimd_stacks  = []
g_stack_labels = []
g_total_label  = None
g_unique_label = None
g_ylabel       = None

# NOTE: set these based on the static configuration
g_cfg_labels = [
  "mimd (a)",
  "1-rr-0c-*l-*h (b)",
  "1-rr-1c-0l-*h (c)",
  "1-rr-1c-1l-0h (d)",
  "1-rr-1c-1l-1h (e)",
  "1-pc-0c-*l-*h (f)",
  "1-pc-1c-0l-*h (g)",
  "1-pc-1c-1l-0h (h)",
  "1-pc-1c-1l-1h (i)",
  "2-rr-0c-*l-*h (j)",
  "2-rr-1c-0l-*h (k)",
  "2-rr-1c-1l-0h (l)",
  "2-rr-1c-1l-1h (m)",
  "2-pc-0c-*l-*h (n)",
  "2-pc-1c-0l-*h (o)",
  "2-pc-1c-1l-0h (p)",
  "2-pc-1c-1l-1h (q)",
]

#-------------------------------------------------------------------------
# select_plot_configs()
#-------------------------------------------------------------------------
# NOTE: select configs based on the static configuration
# Function should return a list of configs for the plot script where each
# config is a subcategory of the bar plot

def select_plot_configs( runtime ):
  limit_lockstep = 0  
  adaptive_hint  = 0
  
  config_list = []
  prefix_str  = 'conj-cores-%s-' % runtime

  for resources in [1,2]:
    for analysis in [0,1]: 
      # "n-ts-0c-*l-*h"
      config_list.append( 
        prefix_str + 
        g_config_str % ( 
          resources, 
          g_ncores, 
          resources, 
          0,              # coalescing
          analysis,       # thread-selection
          0,              # lockstep
          1,              # hint
          limit_lockstep,
          adaptive_hint 
        )
      )
      # "n-ts-1c-0l-*h"
      # "n-ts-1c-1l-0h"
      # "n-ts-1c-1l-1h"
      for lockstep in [0,1]:
        for barrier_limit in [1,1000]:
          if lockstep == 0 and barrier_limit == 1000:
            continue
          config_list.append( 
            prefix_str + 
            g_config_str % ( 
              resources, 
              g_ncores, 
              resources, 
              1,              # coalescing
              analysis,       # thread-selection
              lockstep,       # lockstep
              barrier_limit,  # hint
              limit_lockstep,
              adaptive_hint 
            )
          )
  return config_list

#-------------------------------------------------------------------------
# draw_extras
#-------------------------------------------------------------------------
# NOTE: Will have to tweak this for each static configuration

def draw_extras( opts, apps, df, runtime, perf=True ):
 
  # plot related calculations 
  if   perf: num_subcat = len(opts.data[0])
  else     : num_subcat = len(opts.labels[1])
  width  = opts.bar_width / num_subcat
  offset = (1-opts.bar_width)/2

  # config strings related stuff
  prefix_str   = 'conj-cores-%s-' % runtime
  mimd_cfg_str = 'mimd-%s-1-0AH'
  mimd_cfg     = mimd_cfg_str % runtime

  # constants 
  limit_lockstep = 0
  adaptive_hint  = 0

  #-----------------------------------------------------------------------
  # std. deviation bars for: n-ts-0c-*l-*h
  #----------------------------------------------------------------------- 
  index = 1
  for resources in [1,2]:
    for analysis in [0,1]:
      base_cfg = prefix_str + \
        g_config_str % ( 
          resources, g_ncores, resources, 
          0,              # coalescing
          analysis,       # thread-selection
          0,              # lockstep
          1,              # hint
          limit_lockstep,
          adaptive_hint,
        )
      config_list = []
      for lockstep in range( 2 ):
        for barrier_limit in [1,1000]:
          config_list.append( 
            prefix_str + 
            g_config_str % ( 
              resources, 
              g_ncores, 
              resources, 
              0,              # coalescing
              analysis,       # thread-selection
              lockstep,       # lockstep
              barrier_limit,  # hint
              limit_lockstep,
              adaptive_hint 
            )
          )
      stats = df.loc[df.config.isin(config_list), :]
      data = []
      for app in apps:
        if app not in stats.app.unique():
          continue
        mimd_steps = float(df.loc[(df.app == app) & (df.config == mimd_cfg), 'steps'].iloc[0])
        mimd_work = float(df.loc[(df.app == app) & (df.config == mimd_cfg), g_total_label].iloc[0])
        temp = []
        for cfg in config_list:
          if perf:
            temp.append( stats.loc[(stats.app==app) & (stats.config == cfg), 'steps'].iloc[0]/mimd_steps )
          else:
            temp.append( stats.loc[(stats.app==app) & (stats.config == cfg), g_unique_label].iloc[0]*100/mimd_work )
        data.append( temp )

      # plot the extras now
      indexes = [idx+offset for idx in xrange(len(data))]
      ax = opts.fig.gca()
      for i,idx in enumerate(indexes):
        for y in data[i]:
          ax.scatter( idx + index*width, y, s=50, color='k', marker='*', zorder=100 ) 
      index = index + 4
  
  brg_plot.plt.draw()
  #-----------------------------------------------------------------------

  #-----------------------------------------------------------------------
  # std. deviation bars for: n-ts-1c-0l-*h
  #----------------------------------------------------------------------- 
  index = 2
  for resources in [1,2]:
    for analysis in [0,1]:
      base_cfg = prefix_str + \
        g_config_str % ( 
          resources, g_ncores, resources, 
          1,              # coalescing
          analysis,       # thread-selection
          0,              # lockstep
          1,              # hint
          limit_lockstep,
          adaptive_hint,
        )
      config_list = []
      for barrier_limit in [1,1000]:
        config_list.append( 
          prefix_str + 
          g_config_str % ( 
            resources, 
            g_ncores, 
            resources, 
            1,              # coalescing
            analysis,       # thread-selection
            0,              # lockstep
            barrier_limit,  # hint
            limit_lockstep,
            adaptive_hint 
          )
        )
      stats = df.loc[df.config.isin(config_list), :]
      data = []
      for app in apps:
        if app not in stats.app.unique():
          continue
        mimd_steps = float(df.loc[(df.app == app) & (df.config == mimd_cfg), 'steps'].iloc[0])
        mimd_work = float(df.loc[(df.app == app) & (df.config == mimd_cfg), g_total_label].iloc[0])
        temp = []
        for cfg in config_list:
          if perf:
            temp.append( stats.loc[(stats.app==app) & (stats.config == cfg), 'steps'].iloc[0]/mimd_steps )
          else:
            temp.append( stats.loc[(stats.app==app) & (stats.config == cfg), g_unique_label].iloc[0]*100/mimd_work )
        data.append( temp )

      # plot the extras now
      indexes = [idx+offset for idx in xrange(len(data))]
      ax = opts.fig.gca()
      for i,idx in enumerate(indexes):
        for y in data[i]:
          ax.scatter( idx + index*width, y, s=50, color='k', marker='*', zorder=100 )
      index = index + 4
  
  brg_plot.plt.draw()
  #-----------------------------------------------------------------------

#-------------------------------------------------------------------------
# plot
#-------------------------------------------------------------------------

def plot( df, app_group, runtime ):
  # list of apps based on the app group 
  apps = []
  if   app_group == "custom": apps = app_custom_list
  elif app_group == "pbbs"  : apps = app_pbbs_list
  elif app_group == "cilk"  : apps = app_cilk_list
 
  # create plot options dict
  opts = brg_plot.PlotOptions()
  attribute_dict = \
  {
    'show'            : False,
    'plot_type'       : 'bar',
    'figsize'         : (20.0, 8.0),
    'bar_width'       : 0.9,
  }
  for name, value in attribute_dict.iteritems():
    setattr( opts, name, value )

  opts.num_rows = 2
  opts.num_cols = 1

  index = 1
  mimd_cfg_str = 'mimd-%s-1-0AH'
  mimd_cfg    = mimd_cfg_str % runtime
  config_list = select_plot_configs( runtime )

  #---------------------------------------------------------------------
  # 1. plot performance 
  #---------------------------------------------------------------------

  data   = []
  labels = []
  for app in apps: 
    if app not in df.app.unique():
      continue
    temp = [] 
    try:
      # collect the mimd performance first
      mimd_steps = float(df.loc[(df.app == app) & (df.config == mimd_cfg), 'steps'].iloc[0])
      temp.append( mimd_steps / mimd_steps )
      # collect the performance for the configs of interest
      for cfg in config_list:
        cfg_steps = df.loc[(df.app == app) & (df.config == cfg), 'steps'].iloc[0]
        temp.append( cfg_steps / mimd_steps )
      labels.append( app )
      data.append( temp )
    except:
      continue

  opts.plot_type      = 'bar'
  opts.plot_idx       = index
  opts.normalize_line = 1
  opts.data           = data
  opts.rotate_labels  = False
  opts.labels         = [labels, g_cfg_labels]
  opts.legend_ncol    = len( g_cfg_labels )/2 + 1
  opts.legend_enabled = True
  opts.ylabel         = 'Normalized Delay'
  opts.colors         = brg_plot.colors['unique20']

  brg_plot.add_plot( opts )
  index = index + 1

  draw_extras( opts, apps, df, runtime )
  
  #---------------------------------------------------------------------
  # 2. plot work 
  #---------------------------------------------------------------------

  # collect the mimd work first
  data   = []
  labels = []
  temp = []
  for app in apps:
    if app not in df.app.unique():
      continue
    try:
      mimd_total = float(df.loc[(df.app == app) & (df.config == mimd_cfg), g_total_label].iloc[0])
      vals = [] 
      for stack in g_mimd_stacks:
        vals.append( df.loc[(df.app == app) & (df.config == mimd_cfg), stack].iloc[0] * 100 / mimd_total )
      temp.append(vals)
      labels.append( app )
    except:
      continue
  data.append( temp )
 
  # collect the work for all
  for cfg in config_list:
    temp = [] 
    for app in apps:
      if app not in df.app.unique():
        continue
      try:
        mimd_total = float(df.loc[(df.app == app) & (df.config == mimd_cfg), g_total_label].iloc[0])
        vals = [] 
        for stack in g_stacks:
          vals.append( df.loc[(df.app == app) & (df.config == cfg), stack].iloc[0] * 100 / mimd_total )
        temp.append( vals )
      except:
        continue
    data.append( temp )

  opts.plot_idx            = index 
  opts.plot_type           = 'clustered_stacked_bar'
  opts.normalize_line      = None
  opts.data                = data
  opts.rotate_labels       = True
  subcat_labels = [chr(i) for i in range(ord('a'),ord('q')+1)]
  opts.labels              = [labels,subcat_labels,g_stack_labels]
  opts.legend_ncol         = len( g_stack_labels )
  opts.legend_enabled      = True
  if app_group == 'pbbs' and runtime == 'wsrt':
    opts.label_dist          = -20
    opts.rotate_labels_angle = 45
  else:
    opts.rotate_labels_angle = 0
    opts.label_dist          = -15
  opts.ylabel              = 'Normalized %s (%%)' % ( g_ylabel ) 
  opts.colors              = g_colors

  brg_plot.add_plot( opts )

  draw_extras( opts, apps, df, runtime, perf=False )

  if index == opts.num_rows * opts.num_cols:
    opts.fig.text( 0.5, 1.1, 
      '%s-%s\nCL-NI-%dF-NL' % ( app_group, runtime, g_ncores ), 
      ha='center', fontsize=16
    )
    brg_plot.plt.subplots_adjust(hspace=5)
    brg_plot.plt.tight_layout()
    file_name = '%s-%s-CL-NI-%dF-NL.pdf' % ( app_group, runtime, g_ncores )
    brg_plot.plt.savefig( file_name, bbox_inches="tight" )
    print "saving %s" % file_name
  index = index + 1

#-------------------------------------------------------------------------
# main
#-------------------------------------------------------------------------

if __name__ == "__main__":
  # parse command line arguments
  opts         = parse_cmdline()
  g_insn_ports = opts.g_insn_ports
  g_ncores     = opts.g_ncores
  g_resources  = opts.g_resources
  if g_insn_ports != g_resources:
    print 'Number of cores must match backend resources for ccores configs!'
    exit( 1 )

  if   opts.component == "work":
    g_stacks       = ['unique_daccess', 'unique_execute', 'unique_frontend', 'unique_iaccess']
    g_mimd_stacks  = ['total_daccess', 'total_execute', 'total_frontend', 'total_iaccess']
    g_stack_labels = ['dmem', 'backend', 'frontend', 'imem']
    g_colors       = ['#616161', '#ffffcc', '#8aae92', '#3f6699']
    g_total_label  = 'total_work'
    g_unique_label = 'unique_work'
    g_ylabel       = 'Work'
  elif opts.component == "mem":
    g_stacks       = ['unique_daccess', 'unique_iaccess']
    g_mimd_stacks  = ['total_daccess',  'total_iaccess']
    g_stack_labels = ['dmem', 'imem']
    g_colors       = ['#616161', '#3f6699']
    g_total_label  = 'total_mem'
    g_unique_label = 'unique_mem'
    g_ylabel       = 'Mem Access'
  elif opts.component == "iaccess":
    g_stacks       = ['unique_iaccess']
    g_mimd_stacks  = ['total_iaccess']
    g_stack_labels = ['imem']
    g_colors       = ['#3f6699']
    g_total_label  = 'total_iaccess'
    g_unique_label = 'unique_iaccess'
    g_ylabel       = 'Insn. Access'
  elif opts.component == "daccess":
    g_stacks       = ['unique_daccess']
    g_mimd_stacks  = ['total_daccess']
    g_stack_labels = ['dmem']
    g_colors       = ['#616161']
    g_total_label  = 'total_daccess'
    g_unique_label = 'unique_daccess'
    g_ylabel       = 'Data. Access'
  elif opts.component == "execute":
    g_stacks       = ['unique_execute']
    g_mimd_stacks  = ['total_execute']
    g_stack_labels = ['backend']
    g_colors       = ['#ffffcc']
    g_total_label  = 'total_execute'
    g_unique_label = 'unique_execute'
    g_ylabel       = 'Backend'
  elif opts.component == "frontend":
    g_stacks       = ['unique_frontend']
    g_mimd_stacks  = ['total_frontend']
    g_stack_labels = ['frontend']
    g_colors       = ['#8aae92']
    g_total_label  = 'total_frontend'
    g_unique_label = 'unique_frontend'
    g_ylabel       = 'Frontend'

  # read the data frame
  df = pd.read_csv( g_sim_results_file )

  plot( df, opts.app_group, opts.runtime )
